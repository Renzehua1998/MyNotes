# 基础知识

> 数组是存放在连续内存空间上的相同类型数据的集合，可以方便的通过下标索引的方式获取到下标下对应的数据

- 下标从0开始
- 存储空间地址连续
- 元素不能删除，只能覆盖

注：C++ vector的底层实现是array，vector是容器。

[C++常见容器](https://blog.csdn.net/weixin_43719763/article/details/127147035)

# 704二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

可以用二分法的条件：

- 有序
- 无重复元素

**循环不变量规则**：在while寻找中每一次边界的处理都要坚持根据区间的定义来操作

每次更新left一定是middle+1，因为闭区间不需要考虑一定不满足条件的位置

1. 闭区间：循环判别使用<=，每次更新right=middle-1
2. 左闭右开：循环判别使用<，每次更新right=middle

**似乎左闭右开效率更高，此方案可以避免left==right后再更新middle**

## C++

相关知识：

1. vector类的一些方法

```c++
创建一维vector
vector<int> nums; //不指定长度
vector<int> nums(n); //指定长度
 
添加元素
nums.push_back(1); //直接在末端添加元素1
 
删除元素
nums.resize(num.size-i); //删除后面i个元素
nums.pop_back(); //删除最后一个元素
 
获取长度
nums.size();
 
判空
nums.empty();
nums.size()==0;
```

2. 引用参数传递

函数参数一般分为三种，一种是纯粹的值传递数据参数，第二种是地址传递，第三种是引用传递

- 纯值：形参局部变量不改变实参全局变量
- 地址：传入地址形参（*a）实参（&a），改变全局变量
- 引用：传入引用形参（&a）实参（a），改变全局变量

防止left+right溢出（超出整数范围），可以使用`int middle = left + (right - left) >> 1;`

法二：

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size();
        while (left < right) {
            // int middle = (left + right) >> 1;
            // 防止left+right溢出（超出整数范围）
            int middle = left + (right - left) >> 1;
            if (nums[middle] < target) {
                left = middle + 1;
            } else if (nums[middle] > target) {
                right = middle;
            } else {
                return middle;
            }
        }
        return -1;
    }
};
```

## Python

相关知识：

Python整除是`\\`

python可以不用考虑溢出，因为它的整数int型足够大

法一：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1
        while left <= right:
            middle = (left + right) // 2
            if nums[middle] < target:
                left = middle + 1
            elif nums[middle] > target:
                right = middle -1
            else:
                return middle
        return -1
```

# 27移除元素——快慢指针

**数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。**

1. 爆破法，可以通过，复杂度$O(n^2)$
2. 双指针法：**在数组和链表的操作中是非常常见的**
   - 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
   - 慢指针：指向更新新数组下标的位置

3. 左右指针法：两头逼近，找左边等于val的和右边不等于val的，把右边移到左边，最终返回左指针。

## C++

1. 爆破法

```c++
class Solution {
public:
    // 爆破法
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```

2. 快慢指针法

```c++
class Solution {
public:
    // 快慢指针法
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```

## Python

双指针法

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # 双指针法
        slowIndex = 0
        for fastIndex in range(len(nums)):
            if nums[fastIndex] != val:
                nums[slowIndex] = nums[fastIndex]
                slowIndex += 1
        return slowIndex
```

# 977有序数组的平方——左右指针

注意双指针法循环判断条件为i=j，否则最后一个最小的数就没有了

## C++

1. 平方完快排 O(n)+O(nlogn)

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        for (int i = 0; i < nums.size(); i++) {
            nums[i] *= nums[i];
        }
        sort(nums.begin(),nums.end());
        return nums;
    }
};
```

2. 双指针法O(n)

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int i = 0;
        int j = nums.size() - 1;
        int k = j;
        vector<int> result(nums.size(), 0);  // 初始化一个长度为size的vector，其值都为0
        while (i <= j) {
            if (nums[i] * nums[i] < nums[j] * nums[j]) {
                result[k--] = nums[j] * nums[j];
                j--;
            }
            else {
                result[k--] = nums[i] * nums[i];
                i++;
            }
        }
        return result;
    }
};
```

## Python

- 双指针法

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        i = 0
        n = len(nums)
        j, k = n - 1, n - 1
        result = [0] * n
        while i <= j:
            if nums[i] ** 2 < nums[j] ** 2:
                result[k] = nums[j] ** 2
                j -= 1
            else:
                result[k] = nums[i] ** 2
                i += 1
            k -= 1
        return result
```

# 205长度最小的子数组——滑动窗口

只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置

- 也算是双指针法的一种
- 终止指针为循环遍历索引
- 起始指针控制窗口大小

不要以为for里放一个while就以为是O(n^2)，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。

暴力破解复杂度O(n^2)会超时。

## C++

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int result = INT32_MAX; // 代表无穷大
        int i = 0; // 窗口头指针
        int sum = 0; // 和
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            while (sum >= target) {
                int len = j - i + 1;
                result = result < len ? result : len;
                sum -= nums[i++];
            }
        }
        return result == INT32_MAX ? 0 : result;
    }
};
```

## Python

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        i = 0
        sum = 0
        result = float("inf") # python的float正无穷
        for j in range(len(nums)):
            sum += nums[j]
            while sum >= target:
                result = min(result, j - i + 1)
                sum -= nums[i]
                i += 1
        return 0 if result == float("inf") else result
```

# 59螺旋矩阵II

考察代码掌控的题。坚持**循环不变量原则**。——左闭右开或左开右闭。

奇数需要给中心单独填充。

## C++

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        // 左闭右开
        vector<vector<int>> res(n, vector<int>(n, 0));  // 输出结果
        int loop = n / 2; // 循环次数
        int mid = n / 2; // 中心标号（奇数填充）
        int count = 1; // 填充的数字，每次+1
        int startx = 0, starty = 0; // 循环的开头，每次+1
        int num = n - 1; // 循环时1/4圈填充数字的个数，每次-1
        int i, j; // 循环变量
        while (loop--) {
            // 上
            for (j = starty; j < starty + num; j++) {
                res[startx][j] = count++;
            }
            // 右
            for (i = startx; i < startx + num; i++) {
                res[i][j] = count++;
            }
            // 下
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 左
            for (; i > startx; i--) {
                res[i][j] = count++;
            }
            startx++;
            starty++;
            num -= 2; // 注意每次减2，因为往里少一圈，两边各减一
        }
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```

## Python

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        res = [ [0] * n for _ in range(n)] # 返回二维数组
        loop = n // 2
        mid = n // 2
        startx, starty = 0, 0
        count = 1
        num = n - 1
        while loop:
            for i in range(starty, starty + num):
                res[startx][i] = count
                count += 1
            for i in range(startx, startx + num):
                res[i][starty + num] = count
                count += 1
            for i in range(starty + num, starty, -1):
                res[startx + num][i] = count
                count += 1
            for i in range(startx + num, startx, -1):
                res[i][starty] = count
                count += 1
            startx += 1
            starty += 1
            num -= 2
            loop -= 1
        if (n % 2):
            res[mid][mid] = count
        return res
```


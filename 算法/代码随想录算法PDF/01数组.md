# 基础知识

> 数组是存放在连续内存空间上的相同类型数据的集合，可以方便的通过下标索引的方式获取到下标下对应的数据

- 下标从0开始
- 存储空间地址连续
- 元素不能删除，只能覆盖

注：C++ vector的底层实现是array，vector是容器。

[C++常见容器](https://blog.csdn.net/weixin_43719763/article/details/127147035)

# 二分法

## 704二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

可以用二分法的条件：

- 有序
- 无重复元素

**循环不变量规则**：在while寻找中每一次边界的处理都要坚持根据区间的定义来操作

每次更新left一定是middle+1，因为闭区间不需要考虑一定不满足条件的位置

1. 闭区间：循环判别使用<=，每次更新right=middle-1
2. 左闭右开：循环判别使用<，每次更新right=middle

**似乎左闭右开效率更高，此方案可以避免left==right后再更新middle**

### C++

相关知识：

1. vector类的一些方法

```c++
创建一维vector
vector<int> nums; //不指定长度
vector<int> nums(n); //指定长度
 
添加元素
nums.push_back(1); //直接在末端添加元素1
 
删除元素
nums.resize(num.size-i); //删除后面i个元素
nums.pop_back(); //删除最后一个元素
 
获取长度
nums.size();
 
判空
nums.empty();
nums.size()==0;
```

2. 引用参数传递

函数参数一般分为三种，一种是纯粹的值传递数据参数，第二种是地址传递，第三种是引用传递

- 纯值：形参局部变量不改变实参全局变量
- 地址：传入地址形参（*a）实参（&a），改变全局变量
- 引用：传入引用形参（&a）实参（a），改变全局变量

防止left+right溢出（超出整数范围），可以使用`int middle = left + (right - left) >> 1;`

法二：

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size();
        while (left < right) {
            // int middle = (left + right) >> 1;
            // 防止left+right溢出（超出整数范围）
            int middle = left + (right - left) >> 1;
            if (nums[middle] < target) {
                left = middle + 1;
            } else if (nums[middle] > target) {
                right = middle;
            } else {
                return middle;
            }
        }
        return -1;
    }
};
```

### Python

相关知识：

Python整除是`\\`

python可以不用考虑溢出，因为它的整数int型足够大

法一：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1
        while left <= right:
            middle = (left + right) // 2
            if nums[middle] < target:
                left = middle + 1
            elif nums[middle] > target:
                right = middle -1
            else:
                return middle
        return -1
```

## 35搜索插入位置

### C++

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size();
        int mid = 0;
        while (left < right) {
            mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid;
            } else {
                return mid;
            }
        }
        return right;
    }
};
```

**一定要返回right，返回middle就错了。**按二分法定义，

- 左闭右开区间的时候右指针一定是该插入的位置。
- 闭区间下应该是right+1。

### Python

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid
            else:
                return mid
        return right
```

## 34在排序数组中查找元素的第一个和最后一个位置

### C++

1. 方法1：分别找左右边界，两次二分查找；再判断左右边界的范围
   - 情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}
   - 情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}
   - 情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}

- **使用大于等于二分法查到的一定是左边界，使用小于等于二分法查到的一定是右边界。**
- 左边界使用右指针，右边界使用左指针。
- **为什么border不可以是-1**：有可能在边界上，leftbordee找到的是-1，不好判断。

![image-20230105153000875](01数组/image-20230105153000875.png)

```c++
// 左闭右开区间法
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size();
        int leftBorder = -2, rightBorder = -2;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
                leftBorder = right - 1;
            }
        }
        left = 0;
        right = nums.size();
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] <= target) {
                left = mid + 1;
                rightBorder = left;
            } else {
                right = mid;
            }
        }
        // cout << leftBorder << ' ' << rightBorder << endl;
        // 情况一
        if (leftBorder == -2 || rightBorder == -2) return {-1, -1};
        // 情况三
        if (rightBorder - leftBorder > 1) return {leftBorder + 1, rightBorder - 1};
        // 情况二
        return {-1, -1};
    }
};
```

2. 方法2
   - 二分查找 target，使用大于等于，找左边界
   - 二分查找失败，返回false，结果为[-1,-1]
   - 二分查找成功，返回true，向右游走找右边界
   - 复杂度O(n)，但是一般情况下达不到，可以通过

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size();
        int leftPos = -2; // 第一次找到的位置
        bool find = false; // 是否找到
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
                leftPos = mid - 1;
            }
            if (nums[mid] == target) find = true;
        }
        if (!find) {
            return {-1, -1};
        } else {
            int rightPos;
            for (rightPos = leftPos + 1; rightPos < nums.size() && nums[rightPos] == target; rightPos++) {}
            return {leftPos + 1, rightPos - 1};
        }

    }
};
```

3. 方法3（略）
   - 找target，使用大于等于，找左边界
   - 找target+1，使用大于等于，找左边界，减1得target右边界
   - 判断情况返回即可
   - 其实也是两次二分查找

### Python

闭区间法1：

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        left = 0
        right = len(nums) - 1
        leftPos = -2
        while left <= right:
            mid = (left + right) // 2
            if (nums[mid] < target):
                left = mid + 1
            else:
                right = mid - 1
                leftPos = right
        left = 0
        right = len(nums) - 1
        rightPos = -2
        while left <= right:
            mid = (left + right) // 2
            if (nums[mid] <= target):
                left = mid + 1
                rightPos = left
            else:
                right = mid - 1
        if rightPos - leftPos > 1 and rightPos != -2 and leftPos != -2:
            return [leftPos + 1, rightPos - 1]
        return [-1, -1]
```

## 69*x 的平方根

1. 二分法，每次看mid平方和x的关系
   - 一些小技巧：对于0，1的特殊情况直接返回；使用`int mid = left + (right - left) / 2;``if (mid > x / mid)`等方法防止溢出。
   - 起始右闭区间为n/2时，左区间从1开始，防止输入2 时死循环。
   - 使用闭区间可以避免4的一半2平方是4，从n/2开始会漏掉的问题。
   - 使用右开区间就需要注意要么对4特殊考虑，要么开头从x开始。

2. 牛顿法

![image-20230105184812816](01数组/image-20230105184812816.png)

### C++

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0 || x == 1) return x; // 特殊情况直接返回
        int left = 1;
        int right = x / 2;
        int ans = 1;
        while (left <= right) {
            int mid = left + (right - left) / 2; // 防止溢出
            if (mid > x / mid) { // 防止溢出
                right = mid - 1;
            } else {
                left = mid + 1;
                ans = mid; // 小于等于才符合取整的要求
            }
        }
        return ans;
    }
};
```

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) return 0;
        double C = x, x0 = x, xi = x;
        while (true) {
            xi = 0.5 * (x0 + C / x0);
            if (fabs(x0 - xi) < 1e-7) {
                break;
            }
            x0 = xi;
        }
        return int(x0);
    }
};
```

### Python

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x <= 1:
            return x
        left = 1
        right = x // 2
        while left <= right:
            mid = left + (right - left) // 2
            if mid <= x / mid:  # 不能落了等于，会有刚好满足的情况
                left = mid + 1
                ans = mid
            else:
                right = mid - 1
        return ans
```

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x == 0:
            return x
        C, x0, x1 = x, x, x
        while True:
            x1 = 0.5 * (x0 + C / x0)
            if abs(x0 - x1) < 1e-7:
                break
            x0 = x1
        return int(x0)
```



## 367有效的完全平方数

1. 二分法：

   - 需要注意舍入误差，前面为防止溢出判断时加的`if (mid > num / mid)`，在运算时可能出现不满足条件但返回满足的情况，需要再加一层判断，此时不用担心舍入误差。

   - 或者直接使用long也行

2. 数学法：（骚）
   - 平方数性质1 4=1+3 9=1+3+5 16=1+3+5+7以此类推，模仿它可以使用一个while循环，不断减去一个从1开始不断增大的奇数，若最终减成了0，说明是完全平方数，否则，不是。
3. 牛顿法：同上，迭代找到零点，判断`int(x0) * int(x0) == num`即可。

### C++

```c++
class Solution {
public:
    bool isPerfectSquare(int num) {
        if (num == 1) return true;  // 特殊情况
        int left = 1;
        int right = num / 2;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (mid < num / mid) {
                left = mid + 1;
            } else if (mid > num / mid) {
                right = mid - 1;
            } else {
                if (mid * mid == num) {
                    return true;  // 防止舍入误差，加个判断，此时不会溢出可放心使用
                } else {
                    return false;
                }
            }
        }
        return false;
    }
};
```

```c++
class Solution {
public:
    bool isPerfectSquare(int num) {
        int item = 1;
        while (num > 0) {
            num -= item;
            item += 2;
        }
        return num == 0;
    }
};
```

### Python

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        if num == 1: return True
        left = 1
        right = num // 2
        while left <= right:
            mid = left + (right - left) // 2
            if (mid ** 2 < num):
                left = mid + 1
            elif (mid ** 2 > num):
                right = mid - 1
            else:
                return True
        return False
```

# 快慢指针

## 27移除元素

**数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。**

1. 爆破法，可以通过，复杂度$O(n^2)$
2. 双指针法：**在数组和链表的操作中是非常常见的**
   - 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
   - 慢指针：指向更新新数组下标的位置

3. 左右指针法：两头逼近，找左边等于val的和右边不等于val的，把右边移到左边，最终返回左指针。

### C++

1. 爆破法

```c++
class Solution {
public:
    // 爆破法
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```

2. 快慢指针法

```c++
class Solution {
public:
    // 快慢指针法
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```

### Python

双指针法

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # 双指针法
        slowIndex = 0
        for fastIndex in range(len(nums)):
            if nums[fastIndex] != val:
                nums[slowIndex] = nums[fastIndex]
                slowIndex += 1
        return slowIndex
```

## 其他题目

- 26.删除排序数组中的重复项
- 283.移动零
- 844.比较含退格的字符串
- 977.有序数组的平方

# 左右指针

## 977有序数组的平方

注意双指针法循环判断条件为i=j，否则最后一个最小的数就没有了

### C++

1. 平方完快排 O(n)+O(nlogn)

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        for (int i = 0; i < nums.size(); i++) {
            nums[i] *= nums[i];
        }
        sort(nums.begin(),nums.end());
        return nums;
    }
};
```

2. 双指针法O(n)

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int i = 0;
        int j = nums.size() - 1;
        int k = j;
        vector<int> result(nums.size(), 0);  // 初始化一个长度为size的vector，其值都为0
        while (i <= j) {
            if (nums[i] * nums[i] < nums[j] * nums[j]) {
                result[k--] = nums[j] * nums[j];
                j--;
            }
            else {
                result[k--] = nums[i] * nums[i];
                i++;
            }
        }
        return result;
    }
};
```

### Python

- 双指针法

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        i = 0
        n = len(nums)
        j, k = n - 1, n - 1
        result = [0] * n
        while i <= j:
            if nums[i] ** 2 < nums[j] ** 2:
                result[k] = nums[j] ** 2
                j -= 1
            else:
                result[k] = nums[i] ** 2
                i += 1
            k -= 1
        return result
```

# 滑动窗口

## 205长度最小的子数组

只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置

- 也算是双指针法的一种
- 终止指针为循环遍历索引
- 起始指针控制窗口大小

不要以为for里放一个while就以为是O(n^2)，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。

暴力破解复杂度O(n^2)会超时。

### C++

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int result = INT32_MAX; // 代表无穷大
        int i = 0; // 窗口头指针
        int sum = 0; // 和
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            while (sum >= target) {
                int len = j - i + 1;
                result = result < len ? result : len;
                sum -= nums[i++];
            }
        }
        return result == INT32_MAX ? 0 : result;
    }
};
```

### Python

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        i = 0
        sum = 0
        result = float("inf") # python的float正无穷
        for j in range(len(nums)):
            sum += nums[j]
            while sum >= target:
                result = min(result, j - i + 1)
                sum -= nums[i]
                i += 1
        return 0 if result == float("inf") else result
```

## 其他题目

- 904.水果成篮
- 76.最小覆盖子串

# 模拟行为

## 59*螺旋矩阵II

考察代码掌控的题。坚持**循环不变量原则**。——左闭右开或左开右闭。

奇数需要给中心单独填充。

### C++

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        // 左闭右开
        vector<vector<int>> res(n, vector<int>(n, 0));  // 输出结果
        int loop = n / 2; // 循环次数
        int mid = n / 2; // 中心标号（奇数填充）
        int count = 1; // 填充的数字，每次+1
        int startx = 0, starty = 0; // 循环的开头，每次+1
        int num = n - 1; // 循环时1/4圈填充数字的个数，每次-1
        int i, j; // 循环变量
        while (loop--) {
            // 上
            for (j = starty; j < starty + num; j++) {
                res[startx][j] = count++;
            }
            // 右
            for (i = startx; i < startx + num; i++) {
                res[i][j] = count++;
            }
            // 下
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 左
            for (; i > startx; i--) {
                res[i][j] = count++;
            }
            startx++;
            starty++;
            num -= 2; // 注意每次减2，因为往里少一圈，两边各减一
        }
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```

### Python

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        res = [ [0] * n for _ in range(n)] # 返回二维数组
        loop = n // 2
        mid = n // 2
        startx, starty = 0, 0
        count = 1
        num = n - 1
        while loop:
            for i in range(starty, starty + num):
                res[startx][i] = count
                count += 1
            for i in range(startx, startx + num):
                res[i][starty + num] = count
                count += 1
            for i in range(starty + num, starty, -1):
                res[startx + num][i] = count
                count += 1
            for i in range(startx + num, startx, -1):
                res[i][starty] = count
                count += 1
            startx += 1
            starty += 1
            num -= 2
            loop -= 1
        if (n % 2):
            res[mid][mid] = count
        return res
```

## 其他题目

- 54.螺旋矩阵
- 剑指Offer 29.顺时针打印矩阵
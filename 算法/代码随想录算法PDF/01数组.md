# 基础知识

> 数组是存放在连续内存空间上的相同类型数据的集合，可以方便的通过下标索引的方式获取到下标下对应的数据

- 下标从0开始
- 存储空间地址连续
- 元素不能删除，只能覆盖

注：C++ vector的底层实现是array，vector是容器。

[C++常见容器](https://blog.csdn.net/weixin_43719763/article/details/127147035)

# 二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

可以用二分法的条件：

- 有序
- 无重复元素

**循环不变量规则**：在while寻找中每一次边界的处理都要坚持根据区间的定义来操作

每次更新left一定是middle+1，因为闭区间不需要考虑一定不满足条件的位置

1. 闭区间：循环判别使用<=，每次更新right=middle-1
2. 左闭右开：循环判别使用<，每次更新right=middle

**似乎左闭右开效率更高，此方案可以避免left==right后再更新middle**

## C++

相关知识：

1. vector类的一些方法

```c++
创建一维vector
vector<int> nums; //不指定长度
vector<int> nums(n); //指定长度
 
添加元素
nums.push_back(1); //直接在末端添加元素1
 
删除元素
nums.resize(num.size-i); //删除后面i个元素
nums.pop_back(); //删除最后一个元素
 
获取长度
nums.size();
 
判空
nums.empty();
nums.size()==0;
```

2. 引用参数传递

函数参数一般分为三种，一种是纯粹的值传递数据参数，第二种是地址传递，第三种是引用传递

- 纯值：形参局部变量不改变实参全局变量
- 地址：传入地址形参（*a）实参（&a），改变全局变量
- 引用：传入引用形参（&a）实参（a），改变全局变量

防止left+right溢出（超出整数范围），可以使用`int middle = left + (right - left) >> 1;`

法二：

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size();
        while (left < right) {
            // int middle = (left + right) >> 1;
            // 防止left+right溢出（超出整数范围）
            int middle = left + (right - left) >> 1;
            if (nums[middle] < target) {
                left = middle + 1;
            } else if (nums[middle] > target) {
                right = middle;
            } else {
                return middle;
            }
        }
        return -1;
    }
};
```

## Python

相关知识：

Python整除是`\\`

python可以不用考虑溢出，因为它的整数int型足够大

法一：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1
        while left <= right:
            middle = (left + right) // 2
            if nums[middle] < target:
                left = middle + 1
            elif nums[middle] > target:
                right = middle -1
            else:
                return middle
        return -1
```

# 移除元素

**数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。**

1. 爆破法，可以通过，复杂度$O(n^2)$
2. 双指针法：**在数组和链表的操作中是非常常见的**
   - 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
   - 慢指针：指向更新新数组下标的位置

3. 左右指针法：两头逼近，找左边等于val的和右边不等于val的，把右边移到左边，最终返回左指针。

## C++

1. 爆破法

```c++
class Solution {
public:
    // 爆破法
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```

2. 快慢指针法

```c++
class Solution {
public:
    // 快慢指针法
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```

## Python

双指针法

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # 双指针法
        slowIndex = 0
        for fastIndex in range(len(nums)):
            if nums[fastIndex] != val:
                nums[slowIndex] = nums[fastIndex]
                slowIndex += 1
        return slowIndex
```


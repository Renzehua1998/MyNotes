# 基础知识

> Hash table，散列表。根据关键码的值而直接进行访问的数据结构。
>
> **用来快速判断一个元素是否出现集合里**， 只需要O(1)就可以做到

## 哈希函数

- 把集合元素直接映射为哈希表上的索引
- `hashCode`得到的数值
- 取模——映射到长度为`tableSize`的哈希表上

### 哈希碰撞

- 拉链法：冲突元素存储在链表
- 线性探测法：（`tableSize > dataSize`）冲突了就在表上下一个位置放

## 常见三种哈希结构

- 数组
- set-集合
- map-映射

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

key只能增删，不可以修改

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

key只能增删，不可以修改

**经验**：

- 优先使用unordered（查询、增删效率最高），有序使用set、map，多个key使用multi
- C++中hash_set hash_map，是民间高手自发造的轮子。

**遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**

——牺牲空间换时间

# 242.有效的字母异位词

## C++

[数组初始化](https://blog.csdn.net/u011555996/article/details/124414016)：`int a[3] = {1, 2, 3}`

​	 `int a[3] = {0}` `int* a = new int[3] () // 全部初始化为0`

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        // vector<int> appear(26, 0);  // 三种初始化哈希数组的方式
        // int appear[26] = {0};
        // int* appear = new int[26] ();

        unordered_map <char, int> appear;  // 一种哈希映射的方式
        
        for (int i = 0; i < s.size(); i++) {
            appear[s[i] - 'a']++;
        }
        for (int i = 0; i < t.size(); i++) {
            appear[t[i] - 'a']--;
        }
        for (int i = 0; i < 26; i++) {
            if (appear[i] != 0) {
                return false;
            }
        }
        return true;
    }
};
```

## Python

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        appear = [0] * 26
        for c in s:
            appear[ord(c) - ord('a')] += 1
        for c in t:
            appear[ord(c) - ord('a')] -= 1
        for i in appear:
            if i != 0:
                return False
        return True
```

# 49.字母异位词分组

## C++

unordered_map::count()是C++中的内置方法，用于通过给定 key 对unordered_map中存在的元素数量进行计数。

**注意**：由于unordered_map不允许存储具有重复键的元素，因此count()函数本质上**检查unordered_map中是否存在具有给定键的元素**。

- `sort(tmp.begin(), tmp.end());`给字符串tmp排序

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> res; // 结果
        unordered_map <string, int> repeat; // key：排序后的字符串；value：异位词数组在结果数组的下标
        int index = 0;
        for (auto str: strs) {
            string tmp = str;
            sort(tmp.begin(), tmp.end());  // t作为s排序字符串，异位词将完全相同
            if (repeat.count(tmp)) {
                res[repeat[tmp]].push_back(str);
            } else {
                repeat[tmp] = index++;  // 新字符串排序存入字典，其结果下标自增放入
                vector<string> singleStr(1, str);
                res.push_back(singleStr);
            }
        }
        return res;
    }
};
```

## Python

- `temp = ''.join(sorted(str))`给字符串str排序，放入temp中

```python
# 法1 同C++
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        res = []  # 结果数组
        repeat = {}  # 数量字典
        index = 0
        for str in strs:
            temp = ''.join(sorted(str))
            if temp in repeat:
                res[repeat[temp]].append(str)
            else:
                repeat[temp] = index
                index += 1
                res.append([str])
        return res
# 法2（值直接为返回的字符串数组）
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        repeat = collections.defaultdict(list)  # 结果字典
        for str in strs:
            temp = ''.join(sorted(str))
            repeat[temp].append(str)
        return list(repeat.values())
```

# 438.找到字符串中所有字母异位词

- 爆破O(n^2)
- 滑窗O(n)，每次左移一位，右移一位，判断此时是否满足即可，不用遍历一遍子串。

## C++

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int m = s.length(), n = p.length();
        vector <int> res;
        if (n > m) {  // 特殊情况
            return res;
        }

        vector <int> smap(26, 0), pmap(26, 0);  // 字典
        for (int i = 0; i < n; i++) {
            smap[s[i] - 'a']++;
            pmap[p[i] - 'a']++;
        }
        if (smap == pmap) {
            res.push_back(0);
        }
        for (int i = n; i < m; i++) {
            smap[s[i] - 'a']++;
            smap[s[i-n] - 'a']--;
            if (smap == pmap) {
                res.push_back(i - n + 1);
            }
        }
        return res;
    }
};
```

## Python

```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        m , n = len(s), len(p)
        res = []
        if m < n: return res
        smap = [0] * 26
        pmap = [0] * 26
        for i in range(n):
            smap[ord(s[i]) - ord('a')] += 1
            pmap[ord(p[i]) - ord('a')] += 1
        if smap == pmap: res.append(0)
        for i in range(n, m):
            smap[ord(s[i]) - ord('a')] += 1
            smap[ord(s[i - n]) - ord('a')] -= 1
            if smap == pmap: res.append(i - n + 1)
        return res
```


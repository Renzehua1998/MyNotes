# 基础知识

> 一些深层知识

- 队列是先进先出，栈是先进后出

栈和队列是STL（C++标准库）里面的两个数据结构。三个最为普遍的STL版本：

1. HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。
2. P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。
3. SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。

接下来介绍的栈和队列也是**SGI STL**里面的数据结构

栈：

- 栈提供push 和 pop 等等接口，所有元素必须符合**先进后出**规则
- 栈**不提供走访功能，也不提供迭代器**(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。
- 栈是**以底层容器完成**其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。
- STL中栈往往不被归类为容器，而被归类为container adapter（**容器适配器**）。
- 栈的底层实现可以是vector，deque，list 都是可以的， 主要就是**数组和链表**的底层实现。——默认是以**deque双向队列**为缺省情况下栈的底层结构
- 可以指定vector为底层数据结构

队列：

- **先进先出**的数据结构
- 同样**不允许有遍历行为，不提供迭代器**
- 归类为**容器适配器**
- 以**deque**为缺省情况下的底部结构
- 可以指定list 为起底层实现

# 232.用栈实现队列

- push数据时放进输入栈
- pop数据的时候，若输出栈空，把输入栈搬到输出栈
- 若输出栈非空，直接从输出栈pop
- 两个栈都空，说明清零了

## C++

- 默认stack的pop方法返回void

```c++
class MyQueue {
public:
    stack<int> stIn;
    stack<int> stOut;

    MyQueue() {

    }
    
    void push(int x) {
        stIn.push(x);
    }
    
    int pop() {
        if (stOut.empty()) {
            while (!stIn.empty()) {
                stOut.push(stIn.top());
                stIn.pop();
            } 
        }
        int res = stOut.top();
        stOut.pop();
        return res;
    }
    
    int peek() {
        int res = this->pop();
        stOut.push(res);
        return res;
    }
    
    bool empty() {
        return stIn.empty() && stOut.empty();
    }
};
```

## Python

- 使用list做栈即可

```python
class MyQueue:

    def __init__(self):
        self.stIn = []
        self.stOut = []

    def push(self, x: int) -> None:
        self.stIn.append(x)

    def pop(self) -> int:
        if self.stOut:
            return self.stOut.pop()
        else:
            for i in range(len(self.stIn)):
                self.stOut.append(self.stIn.pop())
            return self.stOut.pop()

    def peek(self) -> int:
        res = self.pop()
        self.stOut.append(res)
        return res

    def empty(self) -> bool:
        return not self.stIn and not self.stOut
```

# 225. 用队列实现栈

1. 两个队列：把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1
2. 一个队列：队列头部的元素（除了最后一个元素外） 重新添加到队列尾部

## C++

```c++
class MyStack {
public:
    queue<int> que;

    MyStack() {

    }
    
    void push(int x) {
        que.push(x);
    }
    
    int pop() {
        int size = que.size() - 1;
        while (size--) {
            que.push(que.front());
            que.pop();
        }
        int res = que.front();
        que.pop();
        return res;
    }
    
    int top() {
        return que.back();
    }
    
    bool empty() {
        return que.empty();
    }
};
```

## Python

```python
from collections import *
class MyStack:

    def __init__(self):
        self.que = deque()

    def push(self, x: int) -> None:
        self.que.append(x)

    def pop(self) -> int:
        for i in range(len(self.que) - 1):
            self.que.append(self.que.popleft())
        return self.que.popleft()

    def top(self) -> int:
        return self.que[-1]

    def empty(self) -> bool:
        return not self.que
```

# 20. 有效的括号

> 对称匹配类题目，经典栈解决的题目

对应的情况：

1. 左括号冗余：最后栈非空
2. 右括号冗余：栈空但还要pop
3. 括号不冗余但类型不匹配：pop的东西和右括号不匹配
4. 匹配：遍历完成，栈也空

![20.有效括号](https://code-thinking.cdn.bcebos.com/gifs/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif)

## C++

```c++
class Solution {
public:
    bool isValid(string s) {
        if (s.size() % 2) {  // 奇数必不满足，剪枝
            return false;
        }
        stack<char> st;
        for (char c : s) {
            if (c == '(') {
                st.push(')');
            } else if (c == '[') {
                st.push(']');
            } else if (c == '{') {
                st.push('}');
            } else if (st.empty() || st.top() != c) { // 半中间栈空了或右括号匹配不上
                return false;
            } else {
                st.pop();
            }
        }
        return st.empty();
    }
};
```

## Python

```python
class Solution:
    def isValid(self, s: str) -> bool:
        if len(s) % 2:
            return False
        st = []
        for c in s:
            if c == '(':
                st.append(')')
            elif c == '[':
                st.append(']')
            elif c == '{':
                st.append('}')
            elif len(st) == 0 or st[-1] != c:
                return False
            else:
                st.pop()
        return not st
```

map法：

```python
class Solution:
    def isValid(self, s: str) -> bool:
        if len(s) % 2:
            return False
        st = []
        mapping = {
            '(' : ')',
            '[' : ']',
            '{' : '}',
        }
        for c in s:
            if c in mapping.keys():
                st.append(mapping[c])
            elif not st or st[-1] != c:
                return False
            else:
                st.pop()
        return not st
```

# 1047. 删除字符串中的所有相邻重复项

1. 使用栈，最后把栈内元素弹出，反向
2. 使用双指针法

## C++

```c++
class Solution {
public:
    string removeDuplicates(string s) {
        stack<char> st;
        for (char c : s) {
            if (st.empty() || st.top() != c) {
                st.push(c);
            } else {
                st.pop();
            }
        }
        string res;
        while (!st.empty()) {
            res += st.top();
            st.pop();
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

```c++
class Solution {
public:
    string removeDuplicates(string s) {
        int slow = 0, fast = 0;
        while (fast < s.size()) {
            s[slow] = s[fast];
            if (slow > 0 && s[slow] == s[slow - 1]) {
                slow--;
            } else {
                slow++;
            }
            fast++;
        }
        return s.substr(0, slow);
    }
};
```

## Python

```python
class Solution:
    def removeDuplicates(self, s: str) -> str:
        st = []
        for c in s:
            if not st or c != st[-1]:
                st.append(c)
            else:
                st.pop()
        return ''.join(st)
```

```python
class Solution {
public:
    string removeDuplicates(string s) {
        int slow = 0, fast = 0;
        while (fast < s.size()) {
            s[slow] = s[fast];
            if (slow > 0 && s[slow] == s[slow - 1]) {
                slow--;
            } else {
                slow++;
            }
            fast++;
        }
        return s.substr(0, slow);
    }
};
```


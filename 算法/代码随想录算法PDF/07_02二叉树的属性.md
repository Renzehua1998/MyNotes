# 101. 对称二叉树

## 递归法

- 递归函数参数与返回值：左、右子树根节点，返回bool类型
- 终止条件：
  1. 左右都为空：true
  2. 一个空，一个不空：false
  3. 都不空但值不相等：false
  4. 都不空且值相等：递归讨论

- 单层递归逻辑：
  - 两个子树外侧是否对称？左的左vs右的右——递归
  - 两个子树内侧是否对称？左的右vs右的左——递归

**C++**

```c++
class Solution {
private:
    bool compare(TreeNode* left, TreeNode* right) {  // 递归比较传入两个子树是否对称
        if (!left && !right) {  // 返回条件
            return true;
        } else if (!left && right) {
            return false;
        } else if (left && !right) {
            return false;
        } else if (left->val != right->val) {
            return false;
        }

        bool outside = compare(left->left, right->right);
        bool inside = compare(left->right, right->left);
        return outside && inside;
    }
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        return compare(root->left, root->right);
    }
};
```

**Python：**

```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        def compare(left, right):
            if not left and not right:
                return True
            elif not left and right:
                return False
            elif left and not right:
                return False
            elif left.val != right.val:
                return False
            
            return compare(left.left, right.right) and compare(left.right, right.left)

        if not root:
            return True
        return compare(root.left, root.right)
```

## 迭代法

- 先压left和right
- 每次pop两个，比较，在压他俩各自要比较的节点
- 遇到不相等就返回false
- 因为是两两比较，栈和队列都可以

**C++：**

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        stack<TreeNode*> st;
        st.push(root->left);
        st.push(root->right);
        while (!st.empty()) {
            TreeNode* left = st.top();
            st.pop();
            TreeNode* right = st.top();
            st.pop();
            if (!left && !right) continue;  // 继续迭代
            if (!left || !right || left->val != right->val) {  // 不对称的情况
                return false;
            }
            st.push(left->left);  // 两两压栈
            st.push(right->right);
            st.push(left->right);
            st.push(right->left);
        }
        return true; // 正常遍历完没返回false，说明对称
    }
};
```

**Python：**

```python
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root: return True
        st = []
        st.append(root.left)
        st.append(root.right)
        while st:
            left = st.pop()
            right = st.pop()
            if not left and not right:
                continue
            if not left or not right or left.val != right.val:
                return False
            st.append(left.left)
            st.append(right.right)
            st.append(left.right)
            st.append(right.left)
        return True
```

## 其他题目

### 100.相同的树

递归法：

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (!p && !q) return true;
        if (!p || !q || p->val != q->val) return false;
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

```python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p and not q: return True
        if not p or not q or p.val != q.val: return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

迭代法：

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        stack<TreeNode*> st;
        st.push(p);
        st.push(q);
        while (!st.empty()) {
            p = st.top();st.pop();
            q = st.top();st.pop();
            if (!p && !q) continue;
            if (!p || !q || p->val != q->val) {
                return false;
            }
            st.push(p->left);
            st.push(q->left);
            st.push(p->right);
            st.push(q->right);
        }
        return true;
    }
};
```

```python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        st = []
        st.append(p)
        st.append(q)
        while st:
            p = st.pop()
            q = st.pop()
            if not p and not q: continue
            if not p or not q or p.val != q.val:
                return False
            st.append(p.left)
            st.append(q.left)
            st.append(p.right)
            st.append(q.right)
        return True
```

### 572*.另一个树的子树

- 双递归法，嵌套了判断是否相等。——深度优先搜索+暴力匹配
- 深度优先遍历（前序），空的左右子节点也压入栈，得到两个数组，进行kmp比较即可。

- [ ] 再好好研究一下官方题解的树哈希法

递归法：

```c++
class Solution {
public:
    bool isSametree(TreeNode* p, TreeNode* q) {
        if (!p && !q) return true;
        if (!p || !q || p->val != q->val) return false;
        return isSametree(p->left, q->left) && isSametree(p->right, q->right);
    }
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if (!subRoot) return true;
        if (!root) return false;
        return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot) || isSametree(root, subRoot);
    }
};
```

```python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p and not q: return True
        if not p or not q or p.val != q.val: return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        if not subRoot: return True
        if not root: return False
        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\
             or self.isSameTree(root, subRoot)
```

前序+串匹配法：

```c++
class Solution {
private:
    // int lNull = INT_MAX;  // 用于填充为空的左右子节点
    // int rNull = INT_MAX - 1;
    void dfsOrder(TreeNode* root, vector<int>& order) {
        if (!root) return;
        order.push_back(root->val);
        if (root->left) {
            dfsOrder(root->left, order);
        } else {
            order.push_back(INT_MAX);
        }
        if (root->right) {
            dfsOrder(root->right, order);
        } else {
            order.push_back(INT_MAX);
        }
    }
    bool kmp(vector<int>& s, vector<int>& t) {
        int lens = s.size(), lent = t.size();
        vector<int> next(lent, -1);
        for (int i = 1, j = -1; i < lent; i++) {
            while (j != -1 && t[i] != t[j + 1]) {
                j = next[j];
            }
            if (t[i] == t[j + 1]) {
                j++;
            }
            next[i] = j;
        }
        for (int i = 0, j = -1; i < lens; i++) {
            while (j != -1 && s[i] != t[j + 1]) {
                j = next[j];
            }
            if (s[i] == t[j + 1]) {
                j++;
            }
            if (j == lent - 1) {
                return true;
            }
        }
        return false;
    }
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        vector<int> rootOrd, subOrd;
        dfsOrder(root, rootOrd);
        dfsOrder(subRoot, subOrd);
        return kmp(rootOrd, subOrd);
    }
};
```

```python
class Solution:
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        import sys

        def dfsOrder(root, order):
            if not root: return
            order.append(root.val)
            if root.left:
                dfsOrder(root.left, order)
            else:
                order.append(sys.maxsize)
            if root.right:
                dfsOrder(root.right, order)
            else:
                order.append(sys.maxsize)

        def kmp(s, t):
            lens = len(s)
            lent = len(t)
            next = [-1] * len(t)
            j = -1
            for i in range(1, lent):
                while j != -1 and t[i] != t[j + 1]:
                    j = next[j]
                if t[i] == t[j + 1]:
                    j += 1
                next[i] = j
            j = -1
            for i in range(lens):
                while j != -1 and s[i] != t[j + 1]:
                    j = next[j]
                if s[i] == t[j + 1]:
                    j += 1
                if j == lent - 1:
                    return True
            return False

        rootOrd = []
        subOrd = []
        dfsOrder(root, rootOrd)
        dfsOrder(subRoot, subOrd)
        return kmp(rootOrd, subOrd)
```


# 基础知识

## 种类

1. **满二叉树**：只有度为0的结点和度为2的结点，并且度为0的结点在同一层上。深度为k，2^(k-1)个节点。

2. **完全二叉树**：仅有最底层可能不满，且最下面一层的节点都集中在该层**最左边的若干位置**。

   优先级队列——**堆就是一棵完全二叉树**，而且父子节点严格有序。

3. **二叉搜索树**：有序树。
   - 左子树上所有结点的值均小于它的根结点的值
   - 右子树上所有结点的值均大于它的根结点的值
   - 左、右子树也分别为二叉排序树

4. **平衡二叉搜索树**：AVL。它是一棵空树或它的左右两个子树的高度差的绝对值不超过1。**C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是logn。——红黑树

## 存储方式

- 链式存储：指针。常用链式表示，也需要知道，数组表示二叉树也是可以的。
- 顺序存储：数组。**数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2**

## 遍历方式

图论里面还会讲到

1. 深度优先：先往深走，遇到叶子节点再往回走
   - 前序：递归、迭代
   - 中序：递归、迭代
   - 后续：递归、迭代
2. 广度优先：一层一层走
   - 层序：迭代

前中后指的都是中间节点的遍历顺序：

![前中后序](07二叉树/20200806191109896.png)

- 一般**深度优先遍历可以用栈**，**广度优先遍历可以用队列**。

## 编程语言定义

**数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来**

- 比链表节点多了一个指针

C++：

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

Python：

```python
class TreeNode: 
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
```

# 递归遍历

递归三要素：

1. **递归函数的参数和返回值**：每次处理什么，返回什么（确定递归函数类型和参数类型）。
2. **终止条件**：防止死循环，确定一定能终止或在内存和时间允许范围内终止。
3. **单层递归的逻辑**：每一层做什么，在此次进行递归。

## C++

```c++
// 前序
class Solution {
public:
    void traversal(TreeNode* node, vector<int>& res) {
        if (node == nullptr) return;
        res.push_back(node->val);
        traversal(node->left, res);
        traversal(node->right, res);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root, res);
        return res;
    }
};

// 后序
class Solution {
public:
    void traversal(TreeNode* node, vector<int>& res) {
        if (node == nullptr) return;
        traversal(node->left, res);
        traversal(node->right, res);
        res.push_back(node->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root, res);
        return res;
    }
};

// 中序
class Solution {
public:
    void traversal(TreeNode* node, vector<int>& res) {
        if (node == nullptr) return;
        traversal(node->left, res);
        res.push_back(node->val);
        traversal(node->right, res);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root, res);
        return res;
    }
};
```

## Python

```python
# 前序
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []

        def traversal(node):
            if node == None:
                return
            res.append(node.val)
            traversal(node.left)
            traversal(node.right)
        
        traversal(root)
        return res

# 后序
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []

        def traversal(node):
            if node == None:
                return
            traversal(node.left)
            traversal(node.right)
            res.append(node.val)
        
        traversal(root)
        return res

# 中序
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []

        def traversal(node):
            if node == None:
                return
            traversal(node.left)
            res.append(node.val)
            traversal(node.right)
        
        traversal(root)
        return res
```

# 迭代遍历*（栈）

- 前序：根节点压栈，每次弹出一个元素，将其值放入结果数组，其右、左节点入栈（若有），这样取的时候就是左、右的顺序。
- 后序：前序压栈的时候先压左，再压右，这样出来是`中右左`，将result整个反转就是`左右中`后序。
- **中序**：处理顺序和访问顺序不一致，需要借用**指针的遍历来帮助访问节点**，**栈则用来处理节点上的元素**。
  - 遍历位置不为null，就压栈，再遍历它的左子节点
  - 为null，就弹栈（回退），栈为空返回；栈不空，弹出的值存入结果，遍历右子节点。

## C++

```c++
// 前序
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        if (root == nullptr) return res;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            res.push_back(node->val);
            if (node->right) st.push(node->right);
            if (node->left) st.push(node->left);
        }
        return res;
    }
};

// 后序
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        if (root == nullptr) return res;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            res.push_back(node->val);
            if (node->left) st.push(node->left);
            if (node->right) st.push(node->right);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};

// 中序
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != nullptr || !st.empty()) {
            if (cur != nullptr) {
                st.push(cur);
                cur = cur->left;
            } else {
                cur = st.top();
                st.pop();
                res.push_back(cur->val);
                cur = cur->right;
            }
        }
        return res;
    }
};
```

## Python

```python
# 前序
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        st = []
        if root == None:
            return res
        st.append(root)
        while st:
            node = st.pop()
            res.append(node.val)
            if node.right:
                st.append(node.right)
            if node.left:
                st.append(node.left)
        return res

# 后序
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        st = []
        if root == None:
            return res
        st.append(root)
        while st:
            node = st.pop()
            res.append(node.val)
            if node.left:
                st.append(node.left)
            if node.right:
                st.append(node.right)
        return res[::-1]

# 中序
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        st = []
        cur = root
        while cur != None or st:
            if cur != None:
                st.append(cur)
                cur = cur.left
            else:
                cur = st.pop()
                res.append(cur.val)
                cur = cur.right
        return res
```

# 统一迭代遍历*

> **将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记**
>
> **要处理的节点放入栈之后，紧接着放入一个空指针作为标记**

——也叫做标记法

## C++

```c++
// 前序
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        if (root) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node) {
                st.pop();
                if (node->right) st.push(node->right);
                if (node->left) st.push(node->left);
                st.push(node);
                st.push(nullptr);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                res.push_back(node->val);
            }
        }
        return res;
    }
};

// 后序
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        if (root) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node) {
                st.pop();
                st.push(node);
                st.push(nullptr);
                if (node->right) st.push(node->right);
                if (node->left) st.push(node->left);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                res.push_back(node->val);
            }
        }
        return res;
    }
};

// 中序
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        if (root) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node) {
                st.pop();
                if (node->right) st.push(node->right);
                st.push(node);
                st.push(nullptr);
                if (node->left) st.push(node->left);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                res.push_back(node->val);
            }
        }
        return res;
    }
};
```

## Python

```python
# 前序
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        st = []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node:
                if node.right:
                    st.append(node.right)
                if node.left:
                    st.append(node.left)
                st.append(node)
                st.append(None)
            else:
                node = st.pop()
                res.append(node.val)
        return res

# 后序
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        st = []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node:
                st.append(node)
                st.append(None)
                if node.right:
                    st.append(node.right)
                if node.left:
                    st.append(node.left)
            else:
                node = st.pop()
                res.append(node.val)
        return res

# 中序
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        st = []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node:
                if node.right:
                    st.append(node.right)
                st.append(node)
                st.append(None)
                if node.left:
                    st.append(node.left)
            else:
                node = st.pop()
                res.append(node.val)
        return res
```

# 层序遍历*
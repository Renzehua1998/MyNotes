# 基础知识

> 又叫回溯搜索法，是一种搜索的方式。
>
> 是递归的副产品，有递归就会有回溯。**回溯函数=递归函数**

**回溯法效率**

- 并不是什么高效的算法，**本质是穷举**
- 为了优化，可以加入剪枝，但改变不了穷举的本质
- 为什么还要用？——没有更好的方法

**回溯法解决的问题**

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

**如何理解回溯**

- 回溯法解决的问题都可以抽象为**树形结构**
- 集合的大小构成了树的宽度，递归的深度构成的树的深度
- 递归需要终止条件，所以必须是高度有限的树——**N叉树**

**回溯法模板**（三部曲）

1. 回溯函数模板**返回值以及参数**：返回值一般为void，参数根据需要动态调整
2. 回溯函数**终止条件**：找到了满足条件的一条答案，把这个答案**存放**起来，并**结束**本层递归
3. 回溯搜索的**遍历过程**：在集合中**递归搜索**，集合的大小构成了树的宽度，递归的深度构成的树的深度。

**伪代码**

——**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**

```Pseudocode
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

# 组合问题
# 基础知识

本质：**选择每一阶段的局部最优，从而达到全局最优**

使用场景：

- 没有具体套路和场景，自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划
- 最好的办法是举反例，有反例就用动态规划，想不出反例就贪心。
- 严格数学证明：数学归纳法（证实）、反证法（证伪）
- **贪心有时候就是常识性的推导**

一般步骤：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

——想清楚局部最优是什么，如何推导出全局最优

# 455.分发饼干

- 大尺寸的饼干优先发给胃口大的小孩：先从最大的饼干开始，看一下能不能满足胃口最大的，如果不能满足就找胃口稍微小一点是再试一下，如果还不能满足就一直找
  1. 饼干数组和小孩数组都排序
  2. 后向遍历小孩数组，用大饼干满足胃口大的
  3. 最终得到的数目就是最多满足小孩的数量

- 小尺寸饼干优先发给胃口小的小孩：先从胃口最小的孩子开始，拿最小的饼干试一下能不能满足他，如果能满足就更好，如果不能满足，在找稍微大一点的，如果还不能满足就再找更大一点的

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int index = 0;
        for (int i = 0; i < s.size(); i++) {
            if (index < g.size() && g[index] <= s[i]) {
                index++;
            }
        }
        return index;
    }
};
```

```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        index = len(s) - 1
        res = 0
        for i in range(len(g) - 1, -1, -1):
            if index >= 0 and s[index] >= g[i]:
                index -= 1
                res += 1
        return res
```

# 376. 摆动序列

## 贪心

> 时间O(n)、空间O(1)

- 局部最优：去掉单调序列中间部分，只保留两端局部极值
- 整体最优：保留所有极值点

特殊情况：**考虑平坡**（两种：平台、台阶）

1. 上下坡中有平坡：允许 prediff == 0 
2. 数组首尾两端：result初始为1（最后一个数肯定要算），curdiff初始值为0（出现差异就算第一个数）
3. 单调坡度有平坡：只在摆动变化的时候更新prediff

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        int curDiff = 0;
        int preDiff = 0;
        int res = 1;
        for (int i = 0; i < nums.size() - 1; i++) {
            curDiff = nums[i + 1] - nums[i];
            if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
                res++;
                preDiff = curDiff;
            }
        }
        return res;
    }
};
```

```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        curDiff = 0
        preDiff = 0
        res = 1
        for i in range(len(nums) - 1):
            curDiff = nums[i + 1] - nums[i]
            if (preDiff <= 0 and curDiff > 0) or (preDiff >= 0 and curDiff < 0):
                res += 1
                preDiff = curDiff
        return res
```

## 动态规划（略）

> 时间O(n^2)、空间O(n)

- 设dp状态`dp[i][0]`，表示考虑前i个数，第i个数作为山峰的摆动子序列的最长长度
- 设dp状态`dp[i][1]`，表示考虑前i个数，第i个数作为山谷的摆动子序列的最长长度

则转移方程为：

- `dp[i][0] = max(dp[i][0], dp[j][1] + 1)`，其中`0 <= j < i`且`nums[j] < nums[i]`，表示将nums[i]接到前面某个山谷后面，作为山峰。
- `dp[i][1] = max(dp[i][1], dp[j][0] + 1)`，其中`0 <= j < i`且`nums[j] > nums[i]`，表示将nums[i]接到前面某个山峰后面，作为山谷。

初始状态：

由于一个数可以接到前面的某个数后面，也可以以自身为子序列的起点，所以初始状态为：`dp[0][0] = dp[0][1] = 1`。

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        vector<vector<int>> dp(nums.size(), vector<int>(2, 1));
        for (int i = 0; i < nums.size(); i++) {
            for (int j = 0; j < i; j++){
                if (nums[j] < nums[i]) dp[i][0] = max(dp[i][0], dp[j][1] + 1);
                if (nums[j] > nums[i]) dp[i][1] = max(dp[i][1], dp[j][0] + 1);
            }
        }
        return max(dp[nums.size() - 1][0], dp[nums.size() - 1][1]);
    }
};
```

```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        dp = []
        for i in range(len(nums)):
            dp.append([1, 1])
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i][0] = max(dp[i][0], dp[j][1] + 1)
                if nums[j] > nums[i]:
                    dp[i][1] = max(dp[i][1], dp[j][0] + 1)
        return max(dp[len(nums) - 1][0], dp[len(nums) - 1][1])
```


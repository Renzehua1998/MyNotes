# 基础知识

本质：**选择每一阶段的局部最优，从而达到全局最优**

使用场景：

- 没有具体套路和场景，自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划
- 最好的办法是举反例，有反例就用动态规划，想不出反例就贪心。
- 严格数学证明：数学归纳法（证实）、反证法（证伪）
- **贪心有时候就是常识性的推导**

一般步骤：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

——想清楚局部最优是什么，如何推导出全局最优

# 455.分发饼干

- 大尺寸的饼干优先发给胃口大的小孩：先从最大的饼干开始，看一下能不能满足胃口最大的，如果不能满足就找胃口稍微小一点是再试一下，如果还不能满足就一直找
  1. 饼干数组和小孩数组都排序
  2. 后向遍历小孩数组，用大饼干满足胃口大的
  3. 最终得到的数目就是最多满足小孩的数量

- 小尺寸饼干优先发给胃口小的小孩：先从胃口最小的孩子开始，拿最小的饼干试一下能不能满足他，如果能满足就更好，如果不能满足，在找稍微大一点的，如果还不能满足就再找更大一点的

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int index = 0;
        for (int i = 0; i < s.size(); i++) {
            if (index < g.size() && g[index] <= s[i]) {
                index++;
            }
        }
        return index;
    }
};
```

```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        index = len(s) - 1
        res = 0
        for i in range(len(g) - 1, -1, -1):
            if index >= 0 and s[index] >= g[i]:
                index -= 1
                res += 1
        return res
```

# 376*. 摆动序列

## 贪心

> 时间O(n)、空间O(1)

- 局部最优：去掉单调序列中间部分，只保留两端局部极值
- 整体最优：保留所有极值点

特殊情况：**考虑平坡**（两种：平台、台阶）

1. 上下坡中有平坡：允许 prediff == 0 
2. 数组首尾两端：result初始为1（最后一个数肯定要算），curdiff初始值为0（出现差异就算第一个数）
3. 单调坡度有平坡：只在摆动变化的时候更新prediff

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        int curDiff = 0;
        int preDiff = 0;
        int res = 1;
        for (int i = 0; i < nums.size() - 1; i++) {
            curDiff = nums[i + 1] - nums[i];
            if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
                res++;
                preDiff = curDiff;
            }
        }
        return res;
    }
};
```

```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        curDiff = 0
        preDiff = 0
        res = 1
        for i in range(len(nums) - 1):
            curDiff = nums[i + 1] - nums[i]
            if (preDiff <= 0 and curDiff > 0) or (preDiff >= 0 and curDiff < 0):
                res += 1
                preDiff = curDiff
        return res
```

## 动态规划（略）

> 时间O(n^2)、空间O(n)

- 设dp状态`dp[i][0]`，表示考虑前i个数，第i个数作为山峰的摆动子序列的最长长度
- 设dp状态`dp[i][1]`，表示考虑前i个数，第i个数作为山谷的摆动子序列的最长长度

则转移方程为：

- `dp[i][0] = max(dp[i][0], dp[j][1] + 1)`，其中`0 <= j < i`且`nums[j] < nums[i]`，表示将nums[i]接到前面某个山谷后面，作为山峰。
- `dp[i][1] = max(dp[i][1], dp[j][0] + 1)`，其中`0 <= j < i`且`nums[j] > nums[i]`，表示将nums[i]接到前面某个山峰后面，作为山谷。

初始状态：

由于一个数可以接到前面的某个数后面，也可以以自身为子序列的起点，所以初始状态为：`dp[0][0] = dp[0][1] = 1`。

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        vector<vector<int>> dp(nums.size(), vector<int>(2, 1));
        for (int i = 0; i < nums.size(); i++) {
            for (int j = 0; j < i; j++){
                if (nums[j] < nums[i]) dp[i][0] = max(dp[i][0], dp[j][1] + 1);
                if (nums[j] > nums[i]) dp[i][1] = max(dp[i][1], dp[j][0] + 1);
            }
        }
        return max(dp[nums.size() - 1][0], dp[nums.size() - 1][1]);
    }
};
```

```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        dp = []
        for i in range(len(nums)):
            dp.append([1, 1])
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i][0] = max(dp[i][0], dp[j][1] + 1)
                if nums[j] > nums[i]:
                    dp[i][1] = max(dp[i][1], dp[j][0] + 1)
        return max(dp[len(nums) - 1][0], dp[len(nums) - 1][1])
```

# 53. 最大子序和

## 贪心

- 局部最优：和为负值时放弃重新开始计算
- 全局最优：最大连续和

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int res = INT32_MIN;
        int count = 0;
        for (int i = 0; i < nums.size(); i++) {
            count += nums[i];
            if (count > res) {
                res = count;
            }
            if (count < 0) {
                count = 0;
            }
        }
        return res;
    }
};
```

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res = -float('inf')
        count = 0
        for num in nums:
            count += num
            if count > res:
                res = count
            if count < 0:
                count = 0
        return res
```

## 动态规划（略）

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if (nums.size() == 0) return 0;  // 特殊情况
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];  // 初始条件
        int res = dp[0];
        for (int i = 1; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
            if (dp[i] > res) res = dp[i];
        }
        return res;
    }
};
```

```c++
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0
        dp = [0] * len(nums)
        dp[0] = nums[0]
        res = dp[0]
        for i in range(1, len(nums)):
            dp[i] = max(dp[i - 1] + nums[i], nums[i])
            if dp[i] > res:
                res = dp[i]
        return res
```

# 122.买卖股票的最佳时机II

- 同一时刻只能买一次，卖完才能买
- 至少两天为一个交易单元

## 贪心

> **最终利润是可以分解的**

- 局部最优：收集每天的正利润（今天减前一天）
- 全局最优：找到最大利润（所有正利润加起来）

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res = 0;
        for (int i = 1; i < prices.size(); i++) {
            res += max(prices[i] - prices[i - 1], 0);
        }
        return res;
    }
};
```

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        res = 0
        for i in range(1, len(prices)):
            res += max(prices[i] - prices[i-1], 0)
        return res
```

## 动态规划（略）

- dp\[i]\[1]第i天持有的最多现金
- dp\[i]\[0]第i天持有股票后的最多现金

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] -= prices[0];  // 初始化
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
        }
        return max(dp[prices.size() - 1][0], dp[prices.size() - 1][1]);
    }
};
```

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        dp = [[0, 0] for _ in range(len(prices))]
        dp[0][0] -= prices[0]
        for i in range(1, len(prices)):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])
        return max(dp[len(prices)-1][0], dp[len(prices)-1][1])
```

# 55.跳跃游戏

> 关键在于可跳的覆盖范围

- 每移动一个单位，就更新最大覆盖范围，最后看能否覆盖到结尾
- 移动范围只能小于等于最大覆盖，覆盖范围大于等于结尾，返回true

- 局部最优：每次根据最大步数更新覆盖范围
- 全局最优：最大覆盖能否到达结尾

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0;
        if (nums.size() == 1) return true;
        for (int i = 0; i <= cover; i++) {
            cover = max(cover, i + nums[i]);
            if (cover >= nums.size() - 1) return true;
        }
        return false;
    }
};
```

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums) == 1:
            return True
        cover = 0
        i = 0
        while i <= cover:
            cover = max(nums[i] + i, cover)
            i += 1
            if cover >= len(nums) - 1:
                return True
        return False
```

# 45.跳跃游戏II

> **以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数**

- 移动下标达到了当前覆盖的最远距离下标时，步数就要加一，来增加覆盖距离。最后的步数就是最少步数
  - 如果当前覆盖最远距离下标不是集合终点，步数就加一，更新当前覆盖距离，还需要继续走。
  - 如果当前覆盖最远距离下标就是集合终点，步数不用加一，因为不能再往后走了。

- **统一处理**：不遍历最后一个元素，就不需要讨论当前覆盖最远距离下标是集合终点的情况了。

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() == 1) return 0;
        int step = 0;
        int curCover = 0;
        int nextCover = 0;
        for (int i = 0; i < nums.size(); i++) {
            nextCover = max(nextCover, nums[i] + i);  // 更新当前最远距离
            if (i == curCover && i < nums.size() - 1) {  // 若i到了最后，就不用加步数
                step++;
                curCover = nextCover;
            }
        }
        return step;
    }
};
// 改进：
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() == 1) return 0;  // 这句可以不要，因为==1时根本不会进入for循环
        int step = 0;
        int curCover = 0;
        int nextCover = 0;
        for (int i = 0; i < nums.size() - 1; i++) {  // 遍历结尾是倒数第二个很重要
            nextCover = max(nextCover, nums[i] + i);  // 更新当前最远距离
            if (i == curCover) {  // 到了倒数第二步，也加。即再来一步就完成。
                step++;
                curCover = nextCover;
            }
        }
        return step;
    }
};
```

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 0
        curCover = 0
        nextCover = 0
        step = 0
        for i in range(len(nums) - 1):
            nextCover = max(nextCover, nums[i] + i)
            if i == curCover:
                step += 1
                curCover = nextCover
        return step
```

# 1005.K次取反后最大化的数组和

- 优先把绝对值最大的负数转换成正数
- 没负数的话把绝对值最小的数变号（连续变即可，若为偶数最终不变，若为奇数最后一个要变号）

步骤：

- 第一步：将数组按照绝对值大小从大到小排序，**注意要按照绝对值的大小**
- 第二步：从前向后遍历，遇到负数将其变为正数，同时K--
- 第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完
- 第四步：求和

——一定要记得k用过一次要减一，还有限制k不能小于0

```c++
class Solution {
public:
    static bool cmp(int x, int y) {
        return abs(x) > abs(y);
    }
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end(), cmp);
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] < 0 && k > 0) {
                nums[i] *= -1;
                k--;
            }
        }
        if (k % 2 == 1) nums[nums.size() - 1] *= -1;
        int res = 0;
        for (int num : nums) res += num;
        return res;
    }
};
```

```python
class Solution:
    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:
        nums.sort(key=abs, reverse=True)
        for i in range(len(nums)):
            if nums[i] < 0 and k > 0:
                nums[i] *= -1
                k -= 1
        if k % 2 == 1:
            nums[-1] *= -1
        return sum(nums)
```

# 134*. 加油站

## 贪心

> i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。

- 局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1
- 全局最优：迭代完成后，总sum大于等于0（一定能跑完），返回迭代得到的起始位置

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int totSum = 0;
        int start = 0;
        for (int i = 0; i < gas.size(); i++) {
            int rest = gas[i] - cost[i];
            totSum += rest;
            curSum += rest;
            if (curSum < 0) {
                start = i + 1;
                curSum = 0;
            }
        }
        if (totSum < 0) return -1;
        return start;
    }
};
```

```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        curSum = 0
        totSum = 0
        start = 0
        for i in range(len(gas)):
            curSum += gas[i] - cost[i]
            totSum += gas[i] - cost[i]
            if curSum < 0:
                start = i + 1
                curSum = 0
        if totSum < 0:
            return -1
        return start
```

## 本题特解

- 情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的
- 情况二：rest[i] = gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。
- 情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能把这个负数填平，能把这个负数填平的节点就是出发节点。

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int minSum = INT32_MAX;
        for (int i = 0; i < gas.size(); i++) {
            int rest = gas[i] - cost[i];
            curSum += rest;
            if (curSum < minSum) minSum = curSum;
        }
        if (curSum < 0) return -1;
        if (minSum >= 0) return 0;
        for (int i = gas.size() - 1; i >= 0; i--) {
            int rest = gas[i] - cost[i];
            minSum += rest;
            if (minSum >= 0) return i;
        }
        return -1;
    }
};
```

```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        curSum = 0
        minSum = float('inf')
        for i in range(len(gas)):
            rest = gas[i] - cost[i]
            curSum += rest
            if curSum < minSum:
                minSum = curSum
        if curSum < 0: return -1
        if minSum >= 0: return 0
        for i in range(len(gas) - 1, -1, -1):
            rest = gas[i] - cost[i]
            minSum += rest
            if minSum >= 0: return i
        return -1
```


# 打家劫舍问题

## 198.打家劫舍

1. dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。
2. 递推公式：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
3. 初始化：
   - dp[0] = nums[0]
   - dp[1] = max(nums[0], nums[1])

4. 遍历顺序：从前往后
5. 举例：

![198.打家劫舍](10_03打家劫舍&股票/20210221170954115.jpg)

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[nums.size() - 1];
    }
};
```

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0: return 0
        if len(nums) == 1: return nums[0]
        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
        return dp[-1]
```

## 213.打家劫舍II

- 在上一题的基础上，考虑两种情况即可包含所有的可能：

![213.打家劫舍II1](10_03打家劫舍&股票/20210129160821374.jpg)

![213.打家劫舍II2](10_03打家劫舍&股票/20210129160842491.jpg)

- 二者取最大值即可

```c++
class Solution {
public:
    int robRange(vector<int>& nums, int start, int end) {
        if (start == end) return nums[start];
        vector<int> dp(nums.size());
        dp[start] = nums[start];
        dp[start + 1] = max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[end];
    }
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        int res1 = robRange(nums, 0, nums.size() - 2);
        int res2 = robRange(nums, 1, nums.size() - 1);
        return max(res1, res2);
    }
};
```

```python
class Solution:
    def robRange(self, nums, start, end):
        if start == end: return nums[start]
        dp = [0] * len(nums)
        dp[start] = nums[start]
        dp[start + 1] = max(nums[start], nums[start + 1])
        for i in range(start + 2, end + 1):
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
        return dp[end]
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0: return 0
        if len(nums) == 1: return nums[0]
        res1 = self.robRange(nums, 0, len(nums) - 2)
        res2 = self.robRange(nums, 1, len(nums) - 1)
        return max(res1, res2)
```

## 337.打家劫舍 III

> 递归回溯+动态规划

### 解法1：单状态

**动规五部曲**：

1. dp[treeNode]：考虑本节点和其所有子孙能获得的最大收益
2. 递推公式：（单层逻辑）
   - 不偷当前节点，则递归返回偷左右节点的最大值和
   - 偷当前节点，则递归返回偷左右各自的左右节点最大值和

3. 初始化：叶子节点值为本身（终止条件）
4. 遍历顺序：依靠孩子算父亲——后序遍历

**递归三部曲**：

1. 函数参数：
   - 输入：当前考虑的根节点
   - 输出：最大收益（int）

2. 终止条件：
   - 遇到空节点，返回0
   - 左右孩子为空，返回本节点的值

3. 单层逻辑：
   - 计算本节点最大收益要靠两个孩子——后序遍历
   - 不偷当前节点，则递归返回偷左右节点的最大值和
   - 偷当前节点，则递归返回偷左右各自的左右节点最大值和

——由于递归存在重复计算（孩子的计算包含了孩子的孩子），可以使用map来记录每个节点对应的最大收益

```c++
class Solution {
public:
    unordered_map<TreeNode*, int> umap;
    int rob(TreeNode* root) {
        if (!root) return 0;
        if (!root->left && !root->right) return root->val;
        if (umap[root]) return umap[root];
        int res1 = root->val;
        if (root->left) res1 += rob(root->left->left) + rob(root->left->right);
        if (root->right) res1 += rob(root->right->left) + rob(root->right->right);
        int res2 = rob(root->left) + rob(root->right);
        umap[root] = max(res1, res2);
        return umap[root];
    }
};
```

- python第122个测试用例会超时

```python
# 超时
class Solution:
    umap = {}
    def rob(self, root: Optional[TreeNode]) -> int:
        if not root: return 0
        if not root.left and not root.right: return root.val
        if root in self.umap.keys(): return self.umap[root]
        #  if self.umap.get(root) is not None:
        res1 = root.val
        if root.left: 
            res1 += self.rob(root.left.left) + self.rob(root.left.right)
        if root.right: 
            res1 += self.rob(root.right.left) + self.rob(root.right.right)
        res2 = self.rob(root.left) + self.rob(root.right)
        return max(res1, res2)
```

### 解法1：双状态

**动规五部曲**：

1. dp[treeNode]长度为2的数组：考虑本节点和其所有子孙

   下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。

2. 递推公式：（单层逻辑）

   - 不偷当前节点，则递归返回偷左右节点的最大值和——dp[0]
   - 偷当前节点，则递归返回偷左右各自的左右节点最大值和——dp[1]

3. 初始化：空节点值为0（终止条件）
4. 遍历顺序：依靠孩子算父亲——后序遍历

**递归三部曲**：

1. 函数参数：
   - 输入：当前考虑的根节点
   - 输出：打劫或不打劫的最大收益（二维`vector<int>`）

2. 终止条件：
   - 遇到空节点，返回[0, 0]

3. 单层逻辑：
   - 计算本节点最大收益要靠两个孩子——后序遍历
   - 分别递归返回左右孩子的结果，
   - dp[0]：不偷当前节点，返回偷左右节点的最大值和
   - dp[1]：偷当前节点，返回偷左右各自的左右节点最大值和

——这种方法可以节约至少一半的递归过程

```c++
class Solution {
public:
    vector<int> robTree(TreeNode* root) {
        if (!root) return vector<int>{0, 0};
        vector<int> left = robTree(root->left);
        vector<int> right = robTree(root->right);
        int res1 = root->val + left[0] + right[0];
        int res2 = max(left[0], left[1]) + max(right[0], right[1]);
        return vector<int>{res2, res1};
    }
    int rob(TreeNode* root) {
        vector<int> res = robTree(root);
        return max(res[0], res[1]);
    }
};
```

```python
class Solution:
    def robTree(self, root: Optional[TreeNode]) -> list:
        if not root: return [0, 0]
        left = self.robTree(root.left)
        right = self.robTree(root.right)
        res1 = root.val + left[0] + right[0]
        res2 = max(left) + max(right)
        return [res2, res1]
    def rob(self, root: Optional[TreeNode]) -> int:
        res = self.robTree(root)
        return max(res)
```


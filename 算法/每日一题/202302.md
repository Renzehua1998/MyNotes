# 2319.判断矩阵是否是一个 X 矩阵

> 2023.01.31 模拟题

如果一个正方形矩阵满足下述 **全部** 条件，则称之为一个 **X 矩阵** ：

1. 矩阵对角线上的所有元素都 **不是 0**
2. 矩阵中所有其他元素都是 **0**

给你一个大小为 `n x n` 的二维整数数组 `grid` ，表示一个正方形矩阵。如果 `grid` 是一个 **X 矩阵** ，返回 `true` ；否则，返回 `false` 。

```c++
class Solution {
public:
    bool checkXMatrix(vector<vector<int>>& grid) {
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid.size(); j++) {
                if (i == j || i + j == grid.size() - 1) {
                    if (!grid[i][j]) return false;
                } else {
                    if (grid[i][j]) return false;
                }
            }
        }
        return true;
    }
};
```

```python
class Solution:
    def checkXMatrix(self, grid: List[List[int]]) -> bool:
        for i in range(len(grid)):
            for j in range(len(grid)):
                if i == j or i + j == len(grid) - 1:
                    if not grid[i][j]: return False
                else:
                    if grid[i][j]: return False
        return True
```

# 2325. 解密消息

> 2023.02.01 哈希表（数组效率更高）

给你字符串 `key` 和 `message` ，分别表示一个加密密钥和一段加密消息。解密 `message` 的步骤如下：

1. 使用 `key` 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 **顺序** 。
2. 将替换表与普通英文字母表对齐，形成对照表。
3. 按照对照表 **替换** `message` 中的每个字母。
4. 空格 `' '` 保持不变。

- 例如，`key = "happy boy"`（实际的加密密钥会包含字母表中每个字母 **至少一次**），据此，可以得到部分对照表（`'h' -> 'a'`、`'a' -> 'b'`、`'p' -> 'c'`、`'y' -> 'd'`、`'b' -> 'e'`、`'o' -> 'f'`）。

返回解密后的消息。

- `26 <= key.length <= 2000`
- `key` 由小写英文字母及 `' '` 组成
- `key` 包含英文字母表中每个字符（`'a'` 到 `'z'`）**至少一次**
- `1 <= message.length <= 2000`
- `message` 由小写英文字母和 `' '` 组成

——使用字符数组存储映射关系，效率更高

```c++
class Solution {
public:
    string decodeMessage(string key, string message) {
        char dict[26]{};  // 对照表
        int index = 0;
        for (char c : key) {
            if (c == ' ') continue;
            if (!dict[c - 'a']) dict[c - 'a'] = 'a' + index++;
        }
        for (char& c : message) {
            if (c == ' ') continue;
            c = dict[c - 'a'];
        }
        return message;
    }
};
```

```python
class Solution:
    def decodeMessage(self, key: str, message: str) -> str:
        dic = {' ': ' '}
        index = 0
        for c in key:
            if c not in dic:
                dic[c] = ascii_lowercase[index]
                index += 1
        return ''.join(dic[c] for c in message)
```

# 1129*.颜色交替的最短路径

> 2022.02.02 图论BFS

在一个有向图中，节点分别标记为 `0, 1, ..., n-1`。图中每条边为红色或者蓝色，且存在自环或平行边。

`red_edges` 中的每一个 `[i, j]` 对表示从节点 `i` 到节点 `j` 的红色有向边。类似地，`blue_edges` 中的每一个 `[i, j]` 对表示从节点 `i` 到节点 `j` 的蓝色有向边。

返回长度为 `n` 的数组 `answer`，其中 `answer[X]` 是从节点 `0` 到节点 `X` 的红色边和蓝色边交替出现的最短路径的长度。如果不存在这样的路径，那么 `answer[x] = -1`。

```c++
class Solution {
public:
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {
        vector<vector<int>> red(n);  // 红色路径，长度为n，resEdge[i] = j表示从i点到j点有一条
        vector<vector<int>> blue(n);  // 蓝色路径， 这两个其实是当map的，使用数组节省空间
        for (vector<int> e : redEdges) {  // 填充映射数组
            red[e[0]].push_back(e[1]);
        }
        for (vector<int> e : blueEdges) {
            blue[e[0]].push_back(e[1]);
        }
        queue<pair<int, int>> que;  // 用于BFS的队列，第一个元素是节点标号，第二个元素0，1分别表示红和蓝
        que.emplace(0, 0);
        que.emplace(0, 1);
        vector<vector<bool>> vis(n, vector<bool>(2, false));  // 记录节点是否被红色or蓝色路径遍历过
        vector<int> ans(n, -1);  // 结果数组，默认全是-1
        int depth = 0;  // 当前遍历深度（最短路径长度）
        while (!que.empty()) {
            int layerNum = que.size();  // 当前遍历层的大小
            while (layerNum) {
                int node = que.front().first;
                int color = que.front().second;
                que.pop();
                if (ans[node] == -1) ans[node] = depth;  // 更新答案
                vis[node][color] = true;  // 本节点找到了答案
                color ^= 1;  // 使用按位异或取反
                if (color) {
                    for (int dest : blue[node]) {
                        if (!vis[dest][1]) que.emplace(dest, 1);
                    }
                } else {
                    for (int dest : red[node]) {
                        if (!vis[dest][0]) que.emplace(dest, 0);
                    }
                }
                layerNum--;  // 计数变量
            }
            depth++;  // 遍历完一层，层数+1
        }
        return ans;
    }
};
```

```python
from collections import *
class Solution:
    def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:
        red = [[] for _ in range(n)]
        blue = [[] for _ in range(n)]
        for e in redEdges:
            red[e[0]].append(e[1])
        for e in blueEdges:
            blue[e[0]].append(e[1])
        que = deque([(0, 0), (0, 1)])
        vis = [[False, False] for _ in range(n)]
        ans = [-1] * n
        depth = 0
        while que:
            layerNum = len(que)
            while layerNum:
                src, color = que.popleft()
                if ans[src] == -1:
                    ans[src] = depth
                vis[src][color] = True
                color ^= 1
                if color:
                    for dest in blue[src]:
                        if not vis[dest][1]:
                            que.append((dest, 1))
                else:
                    for dest in red[src]:
                        if not vis[dest][0]:
                            que.append((dest, 0))
                layerNum -= 1
            depth += 1
        return ans
```

# 1145*. 二叉树着色游戏

> 2022.02.03 二叉树 贪心 dfs

有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点 `root`，树上总共有 `n` 个节点，且 `n` 为奇数，其中每个节点上的值从 `1` 到 `n` 各不相同。

最开始时：

- 「一号」玩家从 `[1, n]` 中取一个值 `x`（`1 <= x <= n`）；
- 「二号」玩家也从 `[1, n]` 中取一个值 `y`（`1 <= y <= n`）且 `y != x`。

「一号」玩家给值为 `x` 的节点染上红色，而「二号」玩家给值为 `y` 的节点染上蓝色。

之后两位玩家轮流进行操作，「一号」玩家先手。每一回合，玩家选择一个被他染过色的节点，将所选节点一个 **未着色** 的邻节点（即左右子节点、或父节点）进行染色（「一号」玩家染红色，「二号」玩家染蓝色）。

如果（且仅在此种情况下）当前玩家无法找到这样的节点来染色时，其回合就会被跳过。

若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。

现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个 `y` 值可以确保你赢得这场游戏，则返回 `true` ；若无法获胜，就请返回 `false` 。

---

[题解](https://leetcode.cn/problems/binary-tree-coloring-game/solutions/2089813/mei-you-si-lu-yi-zhang-tu-miao-dong-pyth-btav/?orderBy=most_votes)：

以 xxx 为根，它的三个邻居（左儿子、右儿子和父节点）就对应着三棵子树：

- 左子树
- 右子树
- 父节点子树

哪棵子树最大，二号玩家就选哪棵。

![1145-2.png](202302/1675081530-kqtMKF-1145-2.png)

```c++
class Solution {
public:
    int leftNum, rightNum, xval;
    int dfs(TreeNode* root) {
        if (!root) return 0;
        int left = dfs(root->left);
        int right = dfs(root->right);
        if (root->val == xval) {
            leftNum = left;
            rightNum = right;
        }
        return left + right + 1;
    }
    bool btreeGameWinningMove(TreeNode* root, int n, int x) {
        xval = x;
        dfs(root);
        return max({leftNum, rightNum, n - leftNum - rightNum - 1}) * 2 > n;
    }
};
```

```python
class Solution:
    def btreeGameWinningMove(self, root: Optional[TreeNode], n: int, x: int) -> bool:
        leftNum, rightNum = 0, 0

        def dfs(root):
            nonlocal leftNum, rightNum
            if not root:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            if root.val == x:
                leftNum = left
                rightNum = right
            return left + right + 1
        
        dfs(root)
        return max(leftNum, rightNum, n - leftNum - rightNum - 1) * 2 > n
```

# 1798. 你能构造出连续值的最大数目

> 2022.02.04 贪心

给你一个长度为 `n` 的整数数组 `coins` ，它代表你拥有的 `n` 个硬币。第 `i` 个硬币的值为 `coins[i]` 。如果你从这些硬币中选出一部分硬币，它们的和为 `x` ，那么称，你可以 **构造** 出 `x` 。

请返回从 `0` 开始（**包括** `0` ），你最多能 **构造** 出多少个连续整数。

你可能有多个相同值的硬币。

---

- 对硬币升序排序
- 每次取一个硬币，看加上它构成的新区间和原来是否重叠
  - 若重叠，更新构建数字范围
  - 若不重叠，跳出循环
- 返回最终数字即可

```c++
class Solution {
public:
    int getMaximumConsecutive(vector<int>& coins) {
        int res = 1;
        sort(coins.begin(), coins.end());
        for (int c : coins) {
            if (c <= res) {
                res += c;
            } else {
                break;
            }
        }
        return res;
    }
};
```

```python
class Solution:
    def getMaximumConsecutive(self, coins: List[int]) -> int:
        res = 0
        coins.sort()
        for c in coins:
            if c > res + 1:
                break
            res += c
        return res + 1
```

# 1210*. 穿过迷宫的最少移动次数

> 2022.02.05 BFS或DP

你还记得那条风靡全球的贪吃蛇吗？

我们在一个 `n*n` 的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角（`(0, 0)` 和 `(0, 1)`）开始移动。我们用 `0` 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角（`(n-1, n-2)` 和 `(n-1, n-1)`）。

每次移动，蛇可以这样走：

- 如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。
- 如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。
- 如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（`(r, c)`、`(r, c+1)`）移动到 （`(r, c)`、`(r+1, c)`）。
   ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-2.png)
- 如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（`(r, c)`、`(r+1, c)`）移动到（`(r, c)`、`(r, c+1)`）。
   ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-1.png)

返回蛇抵达目的地所需的最少移动次数。

如果无法到达目的地，请返回 `-1`。

---

## BFS

- 蛇尾的坐标 (x,y)

- 将蛇的状态本身与 (x,y) 一起形成一个三元组 (x,y,status)——0 表示水平状态，1 表示竖直状态

  当 status=0 时：

      「向右移动」：需要保证 (x,y+2) 是空的单元格；
      「向下移动」：需要保证 (x+1,y)和 (x+1,y+1)均是空的单元格；
      「顺时针旋转」：需要保证 (x+1,y)和 (x+1,y+1)均是空的单元格。

  当 status=1 时：

      「向右移动」：需要保证 (x,y+1) 和 (x+1,y+1)均是空的单元格；
      「向下移动」：需要保证 (x+2,y)是空的单元格；
      「逆时针旋转」：需要保证 (x,y+1)和 (x+1,y+1)均是空的单元格。

- 初始位置为 (0,0,0)，最终位置为 (n−1,n−2,0)

```c++
class Solution {
public:
    int minimumMoves(vector<vector<int>>& grid) {
        int n = grid.size();
        vector<vector<array<int, 2>>> dist(n, vector<array<int, 2>>(n, {-1, -1}));
        dist[0][0][0] = 0;
        queue<tuple<int, int, int>> que;
        que.emplace(0, 0, 0);
        while (!que.empty()) {
            auto [x, y, status] = que.front();
            que.pop();
            if (status) {
                if (y + 1 < n && dist[x][y + 1][1] == -1 && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0) {
                    dist[x][y + 1][1] = dist[x][y][1] + 1;
                    que.emplace(x, y + 1, 1);
                }
                if (x + 2 < n && dist[x + 1][y][1] == -1 && grid[x + 2][y] == 0) {
                    dist[x + 1][y][1] = dist[x][y][1] + 1;
                    que.emplace(x + 1, y, 1);
                }
                if (x + 1 < n && y + 1 < n && dist[x][y][0] == -1 && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0) {
                    dist[x][y][0] = dist[x][y][1] + 1;
                    que.emplace(x, y, 0);
                }
            } else {
                if (x + 1 < n && dist[x + 1][y][0] == -1 && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0) {
                    dist[x + 1][y][0] = dist[x][y][0] + 1;
                    que.emplace(x + 1, y, 0);
                }
                if (y + 2 < n && dist[x][y + 1][0] == -1 && grid[x][y + 2] == 0) {
                    dist[x][y + 1][0] = dist[x][y][0] + 1;
                    que.emplace(x, y + 1, 0);
                }
                if (x + 1 < n && y + 1 < n && dist[x][y][1] == -1 && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0) {
                    dist[x][y][1] = dist[x][y][0] + 1;
                    que.emplace(x, y, 1);
                }
            }
        }
        return dist[n - 1][n - 2][0];
    }
};
```

## DP

[题解](https://leetcode.cn/problems/minimum-moves-to-reach-target-with-rotations/solutions/2091767/chuan-guo-mi-gong-de-zui-shao-yi-dong-ci-pmnh/?orderBy=most_votes)

- 必须保证其左侧的一个格子、上侧的一个格子，另一层同位置的格子都必须已经计算好了。此时我们会发现，左侧与上侧的格子很容易保证，只需要升序遍历x、y，但另一层的同位置格子很难保证，因为两者之间没有固定的顺序关系，所以我们先把两层同一位置的格子都求出来后，再进行两层之间的状态转移，也就是先计算status为0、1各自右移、下移的状态转移，在上述四种状态转移完成之后才进行旋转的这两种状态转移

  作者：智商局局长
  链接：https://leetcode.cn/problems/minimum-moves-to-reach-target-with-rotations/solutions/2093426/xiao-bai-yi-dong-de-guan-fang-ti-jie-jie-akdb/
  来源：力扣（LeetCode）
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```python
class Solution:
    def minimumMoves(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dp = [[[float('inf'), float('inf')] for _ in range(n)] for _ in range(n)]
        dp[0][0][0] = 0
        for i in range(n):
            for j in range(n):
                canHorizontal = (j + 1 < n and grid[i][j] == grid[i][j + 1] == 0)
                canVertical = (i + 1 < n and grid[i][j] == grid[i + 1][j] == 0)
                if i - 1 >= 0 and canHorizontal:
                    dp[i][j][0] = min(dp[i][j][0], dp[i - 1][j][0] + 1)
                if j - 1 >= 0 and canHorizontal:
                    dp[i][j][0] = min(dp[i][j][0], dp[i][j - 1][0] + 1)
                if i - 1 >= 0 and canVertical:
                    dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j][1] + 1)
                if j - 1 >= 0 and canVertical:
                    dp[i][j][1] = min(dp[i][j][1], dp[i][j - 1][1] + 1)
                
                if canHorizontal and canVertical and grid[i + 1][j + 1] == 0:
                    dp[i][j][0] = min(dp[i][j][0], dp[i][j][1] + 1)
                    dp[i][j][1] = min(dp[i][j][1], dp[i][j][0] + 1)
        if dp[n - 1][n - 2][0] == float('inf'):
            return -1
        return dp[n - 1][n - 2][0]
```

# 2331. 计算布尔二叉树的值

> 2022.02.06 二叉树后序遍历

给你一棵 **完整二叉树** 的根，这棵树有以下特征：

- **叶子节点** 要么值为 `0` 要么值为 `1` ，其中 `0` 表示 `False` ，`1` 表示 `True` 。
- **非叶子节点** 要么值为 `2` 要么值为 `3` ，其中 `2` 表示逻辑或 `OR` ，`3` 表示逻辑与 `AND` 。

**计算** 一个节点的值方式如下：

- 如果节点是个叶子节点，那么节点的 **值** 为它本身，即 `True` 或者 `False` 。
- 否则，**计算** 两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 **运算** 。

返回根节点 `root` 的布尔运算值。

**完整二叉树** 是每个节点有 `0` 个或者 `2` 个孩子的二叉树。

**叶子节点** 是没有孩子的节点。

---

```c++
class Solution {
public:
    bool evaluateTree(TreeNode* root) {
        if (!root->left && !root->right) {
            if (root->val) return true;
            else return false;
        }
        bool left = evaluateTree(root->left);
        bool right = evaluateTree(root->right);
        if (root->val == 2) return left || right;
        else return left && right;
    }
};
```

```python
class Solution:
    def evaluateTree(self, root: Optional[TreeNode]) -> bool:
        if not root.left and not root.right:
            if root.val:
                return True
            else:
                return False
        left = self.evaluateTree(root.left)
        right = self.evaluateTree(root.right)
        if root.val == 2:
            return left or right
        else:
            return left and right
```

# 1604*. 警告一小时内使用相同员工卡大于等于三次的人

> 2022.02.07 哈希表+排序

力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 **警告** 。

给你字符串数组 `keyName` 和 `keyTime` ，其中 `[keyName[i], keyTime[i]]` 对应一个人的名字和他在 **某一天** 内使用员工卡的时间。

使用时间的格式是 **24小时制** ，形如 **"HH:MM"** ，比方说 `"23:51"` 和 `"09:49"` 。

请你返回去重后的收到系统警告的员工名字，将它们按 **字典序****升序** 排序后返回。

请注意 `"10:00"` - `"11:00"` 视为一个小时时间范围内，而 `"23:51"` - `"00:10"` 不被视为一小时内，因为系统记录的是某一天内的使用情况。

---

- 先用哈希表 d 记录每个员工的所有打卡时间
- 遍历哈希表，对于每个员工，我们先判断员工的打卡次数是否大于等于 3，如果不是，则跳过该员工。否则，我们将该员工的所有打卡时间按照时间先后排序，然后遍历排序后的打卡时间，判断下标距离为 2 的两个时间是否在同一小时内，如果是，则将该员工加入答案数组
- 最后，将答案数组按照字典序排序

```c++
class Solution {
public:
    vector<string> alertNames(vector<string>& keyName, vector<string>& keyTime) {
        unordered_map<string, vector<int>> keyMap;
        for (int i = 0; i < keyName.size(); i++) {
            string name = keyName[i];
            string time = keyTime[i];
            int t = stoi(time.substr(0, 2)) * 60 + stoi(time.substr(3, 2));
            keyMap[name].push_back(t);
        }
        vector<string> ans;
        for (auto& [name, ts] : keyMap) {
            int n = ts.size();
            if (n > 2) {
                sort(ts.begin(), ts.end());
                for (int i = 0; i < n - 2; i++) {
                    if (ts[i + 2] - ts[i] <= 60) {
                        ans.push_back(name);
                        break;
                    }
                }
            }
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
};
```

```python
class Solution:
    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:
        keyMap = defaultdict(list)
        for i in range(len(keyName)):
            t = int(keyTime[i][:2]) * 60 + int(keyTime[i][3:])
            keyMap[keyName[i]].append(t)
        ans = []
        for name, ts in keyMap.items():
            n = len(ts)
            if n > 2:
                ts.sort()
                for i in range(n - 2):
                    if ts[i + 2] - ts[i] <= 60:
                        ans.append(name)
                        break
        ans.sort()
        return ans
```

# 1233*. 删除子文件夹

> 2022.02.08 排序 or 字典树

## 排序

- 按照字典序排序
- 遍历路径，它的前缀包含答案数组的最后一个文件夹再加上一个 `/`，说明它是上一个的子文件夹，不处理
- 否则就把它压入答案数组

——时间复杂度 $O(n \times \log n \times m)$，空间复杂度 $O(m)$。其中 n 和 m 分别为数组 folder 的长度和数组 folder 中字符串的最大长度。

```c++
class Solution {
public:
    vector<string> removeSubfolders(vector<string>& folder) {
        sort(folder.begin(), folder.end());
        vector<string> ans;
        ans.emplace_back(folder[0]);
        for (int i = 1; i < folder.size(); i++) {
            int m = ans.back().size();
            int n = folder[i].size();
            if (m >= n || !(ans.back() == folder[i].substr(0, m) && folder[i][m] == '/')) {
                ans.emplace_back(folder[i]);
            }
        }
        return ans;
    }
};
```

```python
class Solution:
    def removeSubfolders(self, folder: List[str]) -> List[str]:
        folder.sort()
        ans = [folder[0]]
        for i in range(1, len(folder)):
            m = len(ans[-1])
            n = len(folder[i])
            if m >= n or not (folder[i][:m] == ans[-1] and folder[i][m] == '/'):
                ans.append(folder[i])
        return ans
```

## 字典树*

- 使用字典树存储数组 `folder` 中的所有文件夹
- 每个节点包含 `children` 字段，用于存储当前节点的子节点，以及 `fid` 字段，用于存储当前节点对应的文件夹在数组 `folder` 中的下标。
- 按照`/`添加节点，每一个路径中间文件夹find字段为-1，末尾文件夹find字段为对应下标
- 如果当前节点的 `fid` 字段不为 `-1`，将其加入答案数组并且返回。
- 否则递归地搜索当前节点的所有子节点

——时间复杂度 $O(n \times m)$)，空间复杂度 $O(n \times m)$

```c++
class Trie {
public:
    unordered_map<string, Trie*> children;
    int fid = -1;
    void insert(int fid, string& f) {
        Trie* node = this;
        vector<string> path = split(f);
        for (string& p : path) {
            if (node->children.find(p) == node->children.end()) {
                node->children[p] = new Trie();
            }
            node = node->children[p];
        }
        node->fid = fid;
    }

    vector<string> split(string& f) {
        string temp;
        vector<string> res;
        for (int i = 1; i < f.size(); i++) {
            if (f[i] == '/') {
                res.push_back(temp);
                temp.clear();
            } else {
                temp.push_back(f[i]);
            }
        }
        res.push_back(temp);  // 最后一个别忘了
        return res;
    }
};
class Solution {
public:
    vector<string> ans;
    void dfs(Trie* root, vector<string>& folder) {
        if (root->fid != -1) {
            ans.push_back(folder[root->fid]);
            return;
        }
        for (auto& item : root->children) {
            dfs(item.second, folder);
        }
    }
    vector<string> removeSubfolders(vector<string>& folder) {
        Trie* trie = new Trie();
        for (int i = 0; i < folder.size(); i++) {
            trie->insert(i, folder[i]);
        }
        
        dfs(trie, folder);
        return ans;
    }
};
```

```python
class Trie:
    def __init__(self):
        self.fid = -1
        self.children = {}

    def insert(self, fid, f):
        node = self
        path = f.split('/')
        for p in path[1:]:
            if p not in node.children:
                node.children[p] = Trie()
            node = node.children[p]
        node.fid = fid

class Solution:
    def removeSubfolders(self, folder: List[str]) -> List[str]:
        trie = Trie()
        for i in range(len(folder)):
            trie.insert(i, folder[i])
        ans = []
        
        def dfs(root):
            if root.fid != -1:
                ans.append(folder[root.fid])
                return
            for ch in root.children.values():
                dfs(ch)

        dfs(trie)
        return ans
```


# 2319.判断矩阵是否是一个 X 矩阵

> 2023.01.31 模拟题

如果一个正方形矩阵满足下述 **全部** 条件，则称之为一个 **X 矩阵** ：

1. 矩阵对角线上的所有元素都 **不是 0**
2. 矩阵中所有其他元素都是 **0**

给你一个大小为 `n x n` 的二维整数数组 `grid` ，表示一个正方形矩阵。如果 `grid` 是一个 **X 矩阵** ，返回 `true` ；否则，返回 `false` 。

```c++
class Solution {
public:
    bool checkXMatrix(vector<vector<int>>& grid) {
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid.size(); j++) {
                if (i == j || i + j == grid.size() - 1) {
                    if (!grid[i][j]) return false;
                } else {
                    if (grid[i][j]) return false;
                }
            }
        }
        return true;
    }
};
```

```python
class Solution:
    def checkXMatrix(self, grid: List[List[int]]) -> bool:
        for i in range(len(grid)):
            for j in range(len(grid)):
                if i == j or i + j == len(grid) - 1:
                    if not grid[i][j]: return False
                else:
                    if grid[i][j]: return False
        return True
```

# 2325. 解密消息

> 2023.02.01 哈希表（数组效率更高）

给你字符串 `key` 和 `message` ，分别表示一个加密密钥和一段加密消息。解密 `message` 的步骤如下：

1. 使用 `key` 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 **顺序** 。
2. 将替换表与普通英文字母表对齐，形成对照表。
3. 按照对照表 **替换** `message` 中的每个字母。
4. 空格 `' '` 保持不变。

- 例如，`key = "happy boy"`（实际的加密密钥会包含字母表中每个字母 **至少一次**），据此，可以得到部分对照表（`'h' -> 'a'`、`'a' -> 'b'`、`'p' -> 'c'`、`'y' -> 'd'`、`'b' -> 'e'`、`'o' -> 'f'`）。

返回解密后的消息。

- `26 <= key.length <= 2000`
- `key` 由小写英文字母及 `' '` 组成
- `key` 包含英文字母表中每个字符（`'a'` 到 `'z'`）**至少一次**
- `1 <= message.length <= 2000`
- `message` 由小写英文字母和 `' '` 组成

——使用字符数组存储映射关系，效率更高

```c++
class Solution {
public:
    string decodeMessage(string key, string message) {
        char dict[26]{};  // 对照表
        int index = 0;
        for (char c : key) {
            if (c == ' ') continue;
            if (!dict[c - 'a']) dict[c - 'a'] = 'a' + index++;
        }
        for (char& c : message) {
            if (c == ' ') continue;
            c = dict[c - 'a'];
        }
        return message;
    }
};
```

```python
class Solution:
    def decodeMessage(self, key: str, message: str) -> str:
        dic = {' ': ' '}
        index = 0
        for c in key:
            if c not in dic:
                dic[c] = ascii_lowercase[index]
                index += 1
        return ''.join(dic[c] for c in message)
```


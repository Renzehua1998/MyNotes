# 2319.判断矩阵是否是一个 X 矩阵

> 2023.01.31 模拟题

如果一个正方形矩阵满足下述 **全部** 条件，则称之为一个 **X 矩阵** ：

1. 矩阵对角线上的所有元素都 **不是 0**
2. 矩阵中所有其他元素都是 **0**

给你一个大小为 `n x n` 的二维整数数组 `grid` ，表示一个正方形矩阵。如果 `grid` 是一个 **X 矩阵** ，返回 `true` ；否则，返回 `false` 。

```c++
class Solution {
public:
    bool checkXMatrix(vector<vector<int>>& grid) {
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid.size(); j++) {
                if (i == j || i + j == grid.size() - 1) {
                    if (!grid[i][j]) return false;
                } else {
                    if (grid[i][j]) return false;
                }
            }
        }
        return true;
    }
};
```

```python
class Solution:
    def checkXMatrix(self, grid: List[List[int]]) -> bool:
        for i in range(len(grid)):
            for j in range(len(grid)):
                if i == j or i + j == len(grid) - 1:
                    if not grid[i][j]: return False
                else:
                    if grid[i][j]: return False
        return True
```

# 2325. 解密消息

> 2023.02.01 哈希表（数组效率更高）

给你字符串 `key` 和 `message` ，分别表示一个加密密钥和一段加密消息。解密 `message` 的步骤如下：

1. 使用 `key` 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 **顺序** 。
2. 将替换表与普通英文字母表对齐，形成对照表。
3. 按照对照表 **替换** `message` 中的每个字母。
4. 空格 `' '` 保持不变。

- 例如，`key = "happy boy"`（实际的加密密钥会包含字母表中每个字母 **至少一次**），据此，可以得到部分对照表（`'h' -> 'a'`、`'a' -> 'b'`、`'p' -> 'c'`、`'y' -> 'd'`、`'b' -> 'e'`、`'o' -> 'f'`）。

返回解密后的消息。

- `26 <= key.length <= 2000`
- `key` 由小写英文字母及 `' '` 组成
- `key` 包含英文字母表中每个字符（`'a'` 到 `'z'`）**至少一次**
- `1 <= message.length <= 2000`
- `message` 由小写英文字母和 `' '` 组成

——使用字符数组存储映射关系，效率更高

```c++
class Solution {
public:
    string decodeMessage(string key, string message) {
        char dict[26]{};  // 对照表
        int index = 0;
        for (char c : key) {
            if (c == ' ') continue;
            if (!dict[c - 'a']) dict[c - 'a'] = 'a' + index++;
        }
        for (char& c : message) {
            if (c == ' ') continue;
            c = dict[c - 'a'];
        }
        return message;
    }
};
```

```python
class Solution:
    def decodeMessage(self, key: str, message: str) -> str:
        dic = {' ': ' '}
        index = 0
        for c in key:
            if c not in dic:
                dic[c] = ascii_lowercase[index]
                index += 1
        return ''.join(dic[c] for c in message)
```

# 1129*.颜色交替的最短路径

> 2023.02.02 图论BFS

在一个有向图中，节点分别标记为 `0, 1, ..., n-1`。图中每条边为红色或者蓝色，且存在自环或平行边。

`red_edges` 中的每一个 `[i, j]` 对表示从节点 `i` 到节点 `j` 的红色有向边。类似地，`blue_edges` 中的每一个 `[i, j]` 对表示从节点 `i` 到节点 `j` 的蓝色有向边。

返回长度为 `n` 的数组 `answer`，其中 `answer[X]` 是从节点 `0` 到节点 `X` 的红色边和蓝色边交替出现的最短路径的长度。如果不存在这样的路径，那么 `answer[x] = -1`。

```c++
class Solution {
public:
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {
        vector<vector<int>> red(n);  // 红色路径，长度为n，resEdge[i] = j表示从i点到j点有一条
        vector<vector<int>> blue(n);  // 蓝色路径， 这两个其实是当map的，使用数组节省空间
        for (vector<int> e : redEdges) {  // 填充映射数组
            red[e[0]].push_back(e[1]);
        }
        for (vector<int> e : blueEdges) {
            blue[e[0]].push_back(e[1]);
        }
        queue<pair<int, int>> que;  // 用于BFS的队列，第一个元素是节点标号，第二个元素0，1分别表示红和蓝
        que.emplace(0, 0);
        que.emplace(0, 1);
        vector<vector<bool>> vis(n, vector<bool>(2, false));  // 记录节点是否被红色or蓝色路径遍历过
        vector<int> ans(n, -1);  // 结果数组，默认全是-1
        int depth = 0;  // 当前遍历深度（最短路径长度）
        while (!que.empty()) {
            int layerNum = que.size();  // 当前遍历层的大小
            while (layerNum) {
                int node = que.front().first;
                int color = que.front().second;
                que.pop();
                if (ans[node] == -1) ans[node] = depth;  // 更新答案
                vis[node][color] = true;  // 本节点找到了答案
                color ^= 1;  // 使用按位异或取反
                if (color) {
                    for (int dest : blue[node]) {
                        if (!vis[dest][1]) que.emplace(dest, 1);
                    }
                } else {
                    for (int dest : red[node]) {
                        if (!vis[dest][0]) que.emplace(dest, 0);
                    }
                }
                layerNum--;  // 计数变量
            }
            depth++;  // 遍历完一层，层数+1
        }
        return ans;
    }
};
```

```python
from collections import *
class Solution:
    def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:
        red = [[] for _ in range(n)]
        blue = [[] for _ in range(n)]
        for e in redEdges:
            red[e[0]].append(e[1])
        for e in blueEdges:
            blue[e[0]].append(e[1])
        que = deque([(0, 0), (0, 1)])
        vis = [[False, False] for _ in range(n)]
        ans = [-1] * n
        depth = 0
        while que:
            layerNum = len(que)
            while layerNum:
                src, color = que.popleft()
                if ans[src] == -1:
                    ans[src] = depth
                vis[src][color] = True
                color ^= 1
                if color:
                    for dest in blue[src]:
                        if not vis[dest][1]:
                            que.append((dest, 1))
                else:
                    for dest in red[src]:
                        if not vis[dest][0]:
                            que.append((dest, 0))
                layerNum -= 1
            depth += 1
        return ans
```

# 1145*. 二叉树着色游戏

> 2023.02.03 二叉树 贪心 dfs

有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点 `root`，树上总共有 `n` 个节点，且 `n` 为奇数，其中每个节点上的值从 `1` 到 `n` 各不相同。

最开始时：

- 「一号」玩家从 `[1, n]` 中取一个值 `x`（`1 <= x <= n`）；
- 「二号」玩家也从 `[1, n]` 中取一个值 `y`（`1 <= y <= n`）且 `y != x`。

「一号」玩家给值为 `x` 的节点染上红色，而「二号」玩家给值为 `y` 的节点染上蓝色。

之后两位玩家轮流进行操作，「一号」玩家先手。每一回合，玩家选择一个被他染过色的节点，将所选节点一个 **未着色** 的邻节点（即左右子节点、或父节点）进行染色（「一号」玩家染红色，「二号」玩家染蓝色）。

如果（且仅在此种情况下）当前玩家无法找到这样的节点来染色时，其回合就会被跳过。

若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。

现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个 `y` 值可以确保你赢得这场游戏，则返回 `true` ；若无法获胜，就请返回 `false` 。

---

[题解](https://leetcode.cn/problems/binary-tree-coloring-game/solutions/2089813/mei-you-si-lu-yi-zhang-tu-miao-dong-pyth-btav/?orderBy=most_votes)：

以 xxx 为根，它的三个邻居（左儿子、右儿子和父节点）就对应着三棵子树：

- 左子树
- 右子树
- 父节点子树

哪棵子树最大，二号玩家就选哪棵。

![1145-2.png](202302/1675081530-kqtMKF-1145-2.png)

```c++
class Solution {
public:
    int leftNum, rightNum, xval;
    int dfs(TreeNode* root) {
        if (!root) return 0;
        int left = dfs(root->left);
        int right = dfs(root->right);
        if (root->val == xval) {
            leftNum = left;
            rightNum = right;
        }
        return left + right + 1;
    }
    bool btreeGameWinningMove(TreeNode* root, int n, int x) {
        xval = x;
        dfs(root);
        return max({leftNum, rightNum, n - leftNum - rightNum - 1}) * 2 > n;
    }
};
```

```python
class Solution:
    def btreeGameWinningMove(self, root: Optional[TreeNode], n: int, x: int) -> bool:
        leftNum, rightNum = 0, 0

        def dfs(root):
            nonlocal leftNum, rightNum
            if not root:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            if root.val == x:
                leftNum = left
                rightNum = right
            return left + right + 1
        
        dfs(root)
        return max(leftNum, rightNum, n - leftNum - rightNum - 1) * 2 > n
```

# 1798. 你能构造出连续值的最大数目

> 2023.02.04 贪心

给你一个长度为 `n` 的整数数组 `coins` ，它代表你拥有的 `n` 个硬币。第 `i` 个硬币的值为 `coins[i]` 。如果你从这些硬币中选出一部分硬币，它们的和为 `x` ，那么称，你可以 **构造** 出 `x` 。

请返回从 `0` 开始（**包括** `0` ），你最多能 **构造** 出多少个连续整数。

你可能有多个相同值的硬币。

---

- 对硬币升序排序
- 每次取一个硬币，看加上它构成的新区间和原来是否重叠
  - 若重叠，更新构建数字范围
  - 若不重叠，跳出循环
- 返回最终数字即可

```c++
class Solution {
public:
    int getMaximumConsecutive(vector<int>& coins) {
        int res = 1;
        sort(coins.begin(), coins.end());
        for (int c : coins) {
            if (c <= res) {
                res += c;
            } else {
                break;
            }
        }
        return res;
    }
};
```

```python
class Solution:
    def getMaximumConsecutive(self, coins: List[int]) -> int:
        res = 0
        coins.sort()
        for c in coins:
            if c > res + 1:
                break
            res += c
        return res + 1
```

# 1210*. 穿过迷宫的最少移动次数

> 2023.02.05 BFS或DP

你还记得那条风靡全球的贪吃蛇吗？

我们在一个 `n*n` 的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角（`(0, 0)` 和 `(0, 1)`）开始移动。我们用 `0` 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角（`(n-1, n-2)` 和 `(n-1, n-1)`）。

每次移动，蛇可以这样走：

- 如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。
- 如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。
- 如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（`(r, c)`、`(r, c+1)`）移动到 （`(r, c)`、`(r+1, c)`）。
  ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-2.png)
- 如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（`(r, c)`、`(r+1, c)`）移动到（`(r, c)`、`(r, c+1)`）。
  ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-1.png)

返回蛇抵达目的地所需的最少移动次数。

如果无法到达目的地，请返回 `-1`。

---

## BFS

- 蛇尾的坐标 (x,y)

- 将蛇的状态本身与 (x,y) 一起形成一个三元组 (x,y,status)——0 表示水平状态，1 表示竖直状态

  当 status=0 时：

      「向右移动」：需要保证 (x,y+2) 是空的单元格；
      「向下移动」：需要保证 (x+1,y)和 (x+1,y+1)均是空的单元格；
      「顺时针旋转」：需要保证 (x+1,y)和 (x+1,y+1)均是空的单元格。

  当 status=1 时：

      「向右移动」：需要保证 (x,y+1) 和 (x+1,y+1)均是空的单元格；
      「向下移动」：需要保证 (x+2,y)是空的单元格；
      「逆时针旋转」：需要保证 (x,y+1)和 (x+1,y+1)均是空的单元格。

- 初始位置为 (0,0,0)，最终位置为 (n−1,n−2,0)

```c++
class Solution {
public:
    int minimumMoves(vector<vector<int>>& grid) {
        int n = grid.size();
        vector<vector<array<int, 2>>> dist(n, vector<array<int, 2>>(n, {-1, -1}));
        dist[0][0][0] = 0;
        queue<tuple<int, int, int>> que;
        que.emplace(0, 0, 0);
        while (!que.empty()) {
            auto [x, y, status] = que.front();
            que.pop();
            if (status) {
                if (y + 1 < n && dist[x][y + 1][1] == -1 && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0) {
                    dist[x][y + 1][1] = dist[x][y][1] + 1;
                    que.emplace(x, y + 1, 1);
                }
                if (x + 2 < n && dist[x + 1][y][1] == -1 && grid[x + 2][y] == 0) {
                    dist[x + 1][y][1] = dist[x][y][1] + 1;
                    que.emplace(x + 1, y, 1);
                }
                if (x + 1 < n && y + 1 < n && dist[x][y][0] == -1 && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0) {
                    dist[x][y][0] = dist[x][y][1] + 1;
                    que.emplace(x, y, 0);
                }
            } else {
                if (x + 1 < n && dist[x + 1][y][0] == -1 && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0) {
                    dist[x + 1][y][0] = dist[x][y][0] + 1;
                    que.emplace(x + 1, y, 0);
                }
                if (y + 2 < n && dist[x][y + 1][0] == -1 && grid[x][y + 2] == 0) {
                    dist[x][y + 1][0] = dist[x][y][0] + 1;
                    que.emplace(x, y + 1, 0);
                }
                if (x + 1 < n && y + 1 < n && dist[x][y][1] == -1 && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0) {
                    dist[x][y][1] = dist[x][y][0] + 1;
                    que.emplace(x, y, 1);
                }
            }
        }
        return dist[n - 1][n - 2][0];
    }
};
```

## DP

[题解](https://leetcode.cn/problems/minimum-moves-to-reach-target-with-rotations/solutions/2091767/chuan-guo-mi-gong-de-zui-shao-yi-dong-ci-pmnh/?orderBy=most_votes)

- 必须保证其左侧的一个格子、上侧的一个格子，另一层同位置的格子都必须已经计算好了。此时我们会发现，左侧与上侧的格子很容易保证，只需要升序遍历x、y，但另一层的同位置格子很难保证，因为两者之间没有固定的顺序关系，所以我们先把两层同一位置的格子都求出来后，再进行两层之间的状态转移，也就是先计算status为0、1各自右移、下移的状态转移，在上述四种状态转移完成之后才进行旋转的这两种状态转移

  作者：智商局局长
  链接：https://leetcode.cn/problems/minimum-moves-to-reach-target-with-rotations/solutions/2093426/xiao-bai-yi-dong-de-guan-fang-ti-jie-jie-akdb/
  来源：力扣（LeetCode）
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```python
class Solution:
    def minimumMoves(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dp = [[[float('inf'), float('inf')] for _ in range(n)] for _ in range(n)]
        dp[0][0][0] = 0
        for i in range(n):
            for j in range(n):
                canHorizontal = (j + 1 < n and grid[i][j] == grid[i][j + 1] == 0)
                canVertical = (i + 1 < n and grid[i][j] == grid[i + 1][j] == 0)
                if i - 1 >= 0 and canHorizontal:
                    dp[i][j][0] = min(dp[i][j][0], dp[i - 1][j][0] + 1)
                if j - 1 >= 0 and canHorizontal:
                    dp[i][j][0] = min(dp[i][j][0], dp[i][j - 1][0] + 1)
                if i - 1 >= 0 and canVertical:
                    dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j][1] + 1)
                if j - 1 >= 0 and canVertical:
                    dp[i][j][1] = min(dp[i][j][1], dp[i][j - 1][1] + 1)
                
                if canHorizontal and canVertical and grid[i + 1][j + 1] == 0:
                    dp[i][j][0] = min(dp[i][j][0], dp[i][j][1] + 1)
                    dp[i][j][1] = min(dp[i][j][1], dp[i][j][0] + 1)
        if dp[n - 1][n - 2][0] == float('inf'):
            return -1
        return dp[n - 1][n - 2][0]
```

# 2331. 计算布尔二叉树的值

> 2023.02.06 二叉树后序遍历

给你一棵 **完整二叉树** 的根，这棵树有以下特征：

- **叶子节点** 要么值为 `0` 要么值为 `1` ，其中 `0` 表示 `False` ，`1` 表示 `True` 。
- **非叶子节点** 要么值为 `2` 要么值为 `3` ，其中 `2` 表示逻辑或 `OR` ，`3` 表示逻辑与 `AND` 。

**计算** 一个节点的值方式如下：

- 如果节点是个叶子节点，那么节点的 **值** 为它本身，即 `True` 或者 `False` 。
- 否则，**计算** 两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 **运算** 。

返回根节点 `root` 的布尔运算值。

**完整二叉树** 是每个节点有 `0` 个或者 `2` 个孩子的二叉树。

**叶子节点** 是没有孩子的节点。

---

```c++
class Solution {
public:
    bool evaluateTree(TreeNode* root) {
        if (!root->left && !root->right) {
            if (root->val) return true;
            else return false;
        }
        bool left = evaluateTree(root->left);
        bool right = evaluateTree(root->right);
        if (root->val == 2) return left || right;
        else return left && right;
    }
};
```

```python
class Solution:
    def evaluateTree(self, root: Optional[TreeNode]) -> bool:
        if not root.left and not root.right:
            if root.val:
                return True
            else:
                return False
        left = self.evaluateTree(root.left)
        right = self.evaluateTree(root.right)
        if root.val == 2:
            return left or right
        else:
            return left and right
```

# 1604*. 警告一小时内使用相同员工卡大于等于三次的人

> 2023.02.07 哈希表+排序

力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 **警告** 。

给你字符串数组 `keyName` 和 `keyTime` ，其中 `[keyName[i], keyTime[i]]` 对应一个人的名字和他在 **某一天** 内使用员工卡的时间。

使用时间的格式是 **24小时制** ，形如 **"HH:MM"** ，比方说 `"23:51"` 和 `"09:49"` 。

请你返回去重后的收到系统警告的员工名字，将它们按 **字典序****升序** 排序后返回。

请注意 `"10:00"` - `"11:00"` 视为一个小时时间范围内，而 `"23:51"` - `"00:10"` 不被视为一小时内，因为系统记录的是某一天内的使用情况。

---

- 先用哈希表 d 记录每个员工的所有打卡时间
- 遍历哈希表，对于每个员工，我们先判断员工的打卡次数是否大于等于 3，如果不是，则跳过该员工。否则，我们将该员工的所有打卡时间按照时间先后排序，然后遍历排序后的打卡时间，判断下标距离为 2 的两个时间是否在同一小时内，如果是，则将该员工加入答案数组
- 最后，将答案数组按照字典序排序

```c++
class Solution {
public:
    vector<string> alertNames(vector<string>& keyName, vector<string>& keyTime) {
        unordered_map<string, vector<int>> keyMap;
        for (int i = 0; i < keyName.size(); i++) {
            string name = keyName[i];
            string time = keyTime[i];
            int t = stoi(time.substr(0, 2)) * 60 + stoi(time.substr(3, 2));
            keyMap[name].push_back(t);
        }
        vector<string> ans;
        for (auto& [name, ts] : keyMap) {
            int n = ts.size();
            if (n > 2) {
                sort(ts.begin(), ts.end());
                for (int i = 0; i < n - 2; i++) {
                    if (ts[i + 2] - ts[i] <= 60) {
                        ans.push_back(name);
                        break;
                    }
                }
            }
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
};
```

```python
class Solution:
    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:
        keyMap = defaultdict(list)
        for i in range(len(keyName)):
            t = int(keyTime[i][:2]) * 60 + int(keyTime[i][3:])
            keyMap[keyName[i]].append(t)
        ans = []
        for name, ts in keyMap.items():
            n = len(ts)
            if n > 2:
                ts.sort()
                for i in range(n - 2):
                    if ts[i + 2] - ts[i] <= 60:
                        ans.append(name)
                        break
        ans.sort()
        return ans
```

# 1233*. 删除子文件夹

> 2023.02.08 排序 or 字典树

## 排序

- 按照字典序排序
- 遍历路径，它的前缀包含答案数组的最后一个文件夹再加上一个 `/`，说明它是上一个的子文件夹，不处理
- 否则就把它压入答案数组

——时间复杂度 $O(n \times \log n \times m)$，空间复杂度 $O(m)$。其中 n 和 m 分别为数组 folder 的长度和数组 folder 中字符串的最大长度。

```c++
class Solution {
public:
    vector<string> removeSubfolders(vector<string>& folder) {
        sort(folder.begin(), folder.end());
        vector<string> ans;
        ans.emplace_back(folder[0]);
        for (int i = 1; i < folder.size(); i++) {
            int m = ans.back().size();
            int n = folder[i].size();
            if (m >= n || !(ans.back() == folder[i].substr(0, m) && folder[i][m] == '/')) {
                ans.emplace_back(folder[i]);
            }
        }
        return ans;
    }
};
```

```python
class Solution:
    def removeSubfolders(self, folder: List[str]) -> List[str]:
        folder.sort()
        ans = [folder[0]]
        for i in range(1, len(folder)):
            m = len(ans[-1])
            n = len(folder[i])
            if m >= n or not (folder[i][:m] == ans[-1] and folder[i][m] == '/'):
                ans.append(folder[i])
        return ans
```

## 字典树*

- 使用字典树存储数组 `folder` 中的所有文件夹
- 每个节点包含 `children` 字段，用于存储当前节点的子节点，以及 `fid` 字段，用于存储当前节点对应的文件夹在数组 `folder` 中的下标。
- 按照`/`添加节点，每一个路径中间文件夹find字段为-1，末尾文件夹find字段为对应下标
- 如果当前节点的 `fid` 字段不为 `-1`，将其加入答案数组并且返回。
- 否则递归地搜索当前节点的所有子节点

——时间复杂度 $O(n \times m)$)，空间复杂度 $O(n \times m)$

```c++
class Trie {
public:
    unordered_map<string, Trie*> children;
    int fid = -1;
    void insert(int fid, string& f) {
        Trie* node = this;
        vector<string> path = split(f);
        for (string& p : path) {
            if (node->children.find(p) == node->children.end()) {
                node->children[p] = new Trie();
            }
            node = node->children[p];
        }
        node->fid = fid;
    }

    vector<string> split(string& f) {
        string temp;
        vector<string> res;
        for (int i = 1; i < f.size(); i++) {
            if (f[i] == '/') {
                res.push_back(temp);
                temp.clear();
            } else {
                temp.push_back(f[i]);
            }
        }
        res.push_back(temp);  // 最后一个别忘了
        return res;
    }
};
class Solution {
public:
    vector<string> ans;
    void dfs(Trie* root, vector<string>& folder) {
        if (root->fid != -1) {
            ans.push_back(folder[root->fid]);
            return;
        }
        for (auto& item : root->children) {
            dfs(item.second, folder);
        }
    }
    vector<string> removeSubfolders(vector<string>& folder) {
        Trie* trie = new Trie();
        for (int i = 0; i < folder.size(); i++) {
            trie->insert(i, folder[i]);
        }
        
        dfs(trie, folder);
        return ans;
    }
};
```

```python
class Trie:
    def __init__(self):
        self.fid = -1
        self.children = {}

    def insert(self, fid, f):
        node = self
        path = f.split('/')
        for p in path[1:]:
            if p not in node.children:
                node.children[p] = Trie()
            node = node.children[p]
        node.fid = fid

class Solution:
    def removeSubfolders(self, folder: List[str]) -> List[str]:
        trie = Trie()
        for i in range(len(folder)):
            trie.insert(i, folder[i])
        ans = []
        
        def dfs(root):
            if root.fid != -1:
                ans.append(folder[root.fid])
                return
            for ch in root.children.values():
                dfs(ch)

        dfs(trie)
        return ans
```

# 1797. 设计一个验证系统

> 2023.02.09 哈希表 类定义

你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 `currentTime` 时刻之后 `timeToLive` 秒过期。如果验证码被更新了，那么它会在 `currentTime` （可能与之前的 `currentTime` 不同）时刻延长 `timeToLive` 秒。

请你实现 `AuthenticationManager` 类：

- `AuthenticationManager(int timeToLive)` 构造 `AuthenticationManager` 并设置 `timeToLive` 参数。
- `generate(string tokenId, int currentTime)` 给定 `tokenId` ，在当前时间 `currentTime` 生成一个新的验证码。
- `renew(string tokenId, int currentTime)` 将给定 `tokenId` 且 **未过期** 的验证码在 `currentTime` 时刻更新。如果给定 `tokenId` 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。
- `countUnexpiredTokens(int currentTime)` 请返回在给定 `currentTime` 时刻，**未过期** 的验证码数目。

如果一个验证码在时刻 `t` 过期，且另一个操作恰好在时刻 `t` 发生（`renew` 或者 `countUnexpiredTokens` 操作），过期事件 **优先于** 其他操作。

---

```c++
class AuthenticationManager {
public:
    int t;
    unordered_map<string, int> tokenMap;

    AuthenticationManager(int timeToLive) {
        t = timeToLive;
    }
    
    void generate(string tokenId, int currentTime) {
        tokenMap[tokenId] = currentTime + t;
    }
    
    void renew(string tokenId, int currentTime) {
        if (tokenMap[tokenId] > currentTime) {
            tokenMap[tokenId] = currentTime + t;
        }
    }
    
    int countUnexpiredTokens(int currentTime) {
        int num = 0;
        for (auto& item : tokenMap) {
            if (item.second > currentTime) {
                num++;
            }
        }
        return num;
    }
};
```

```python
class AuthenticationManager:

    def __init__(self, timeToLive: int):
        self.timeToLive = timeToLive
        self.tokenMap = defaultdict(int)

    def generate(self, tokenId: str, currentTime: int) -> None:
        self.tokenMap[tokenId] = currentTime + self.timeToLive

    def renew(self, tokenId: str, currentTime: int) -> None:
        if self.tokenMap[tokenId] > currentTime:
            self.tokenMap[tokenId] = currentTime + self.timeToLive

    def countUnexpiredTokens(self, currentTime: int) -> int:
        num = 0
        for time in self.tokenMap.values():
            if time > currentTime:
                num += 1
        return num
```

# 1223*. 掷骰子模拟

> 2023.02.10 动态规划

有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。

不过我们在使用它时有个约束，就是使得投掷骰子时，**连续** 掷出数字 `i` 的次数不能超过 `rollMax[i]`（`i` 从 1 开始编号）。

现在，给你一个整数数组 `rollMax` 和一个整数 `n`，请你来计算掷 `n` 次骰子可得到的不同点数序列的数量。

假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 **模 `10^9 + 7`** 之后的结果。

---

## 一般三维动态规划

1. `dp[i][last][left]`表示后面还有i个数字、上一个数字为last，last还能重复left次时掷色子的总次数
2. 递推公式：
   - 遍历六个点数，把它们全加起来再模那个值
   - 当点数`j==last`且left不为0（还能重复出现j）时，`res += dp[i - 1][j][left - 1] `
   - 当点数`j!=last`时，`res += dp[i - 1][j][rollMax[j] - 1] `

3. 初始化：`dp[0][last][left]`全部为1——即只可能出现一次
4. 遍历顺序：按维度从小到大遍历即可

```c++
class Solution {
public:
    const long MOD = 1e9 + 7;
    int dieSimulator(int n, vector<int>& rollMax) {
        int m = rollMax.size();
        int dp[n][m][15];
        for (int last = 0; last < m; last++) {  // 初始化
            for (int left = 0; left < rollMax[last]; left++) {
                dp[0][last][left] = 1;
            }
        }
        for (int i = 1; i < n; i++) {  // 迭代遍历求dp数组
            for (int last = 0; last < m; last++) {
                for (int left = 0; left < rollMax[last]; left++) {
                    long res = 0;
                    for (int j = 0; j < m; j++) {
                        if (j != last) res += dp[i - 1][j][rollMax[j] - 1];
                        else if (left) res += dp[i - 1][j][left - 1];
                    }
                    dp[i][last][left] = res % MOD;
                }
            }
        }
        long ans = 0;
        for (int j = 0; j < m; j++) {
            ans += dp[n - 1][j][rollMax[j] - 1];
        }
        return ans % MOD;
    }
};
```

```
class Solution:
    def dieSimulator(self, n: int, rollMax: List[int]) -> int:
        MOD = 10 ** 9 + 7
        m = len(rollMax)
        dp = [[[1] * 15 for _ in range(m)] for _ in range(n)]
        for i in range(1, n):
            for last in range(m):
                for left in range(rollMax[last]):
                    res = 0
                    for j in range(m):
                        if j != last:
                            res += dp[i - 1][j][rollMax[j] - 1]
                        elif left > 0:
                            res += dp[i - 1][j][left - 1]
                    dp[i][last][left] = res % MOD
        ans = 0
        for j in range(m):
            ans += dp[n - 1][j][rollMax[j] - 1]
        return ans % MOD
```

## 动规状态优化

1. `dp[i][j]`表示第i个数字为j时掷色子的总次数

2. 递推公式：

   - 前一次六个数字的可能相加，减去多余
   - 多余为：`i-数字j出现最多的次数-1`次时，不取j的总次数

   ![image.png](https://pic.leetcode-cn.com/1605878536-qZHxBN-image.png)

3. 初始化：`dp[0][j]`全部为1——刚开始的数量都是1

4. 遍历顺序：按维度从小到大遍历即可

——注意，第二部分下标计算出为-1时为特殊情况，即从0到i的色子数都是j，那么第二项为1即可

```c++
class Solution {
public:
    const long MOD = 1e9 + 7;
    int dieSimulator(int n, vector<int>& rollMax) {
        int m = rollMax.size();
        vector<vector<int>> dp(n, vector<int>(m, 1));
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                long res = 0;
                for (int k = 0; k < m; k++) {
                    res += dp[i - 1][k];
                }
                int index = i - rollMax[j] - 1;
                if (index == -1) res -= 1;  // 特殊情况
                else if (index >= 0) { // 减去重复值
                    for (int k = 0; k < m; k++) {
                        res -= dp[index][k];
                    }
                    res += dp[index][j]; // 多减掉的加回来
                }
                dp[i][j] = (res % MOD + MOD) % MOD; // 防止出现负数(重要！)
            }
        }
        long ans = 0;
        for (int k = 0; k < m; k++) {
            ans += dp[n - 1][k];
        }
        return ans % MOD;
    }
};
```

```python
class Solution:
    def dieSimulator(self, n: int, rollMax: List[int]) -> int:
        MOD = 10 ** 9 + 7
        m = len(rollMax)
        dp = [[1] * m for _ in range(n)]
        for i in range(1, n):
            for j in range(m):
                res = 0
                for k in range(m):
                    res += dp[i - 1][k]
                index = i - rollMax[j] - 1
                if index == -1:
                    res -= 1
                elif index >= 0:
                    for k in range(m):
                        res -= dp[index][k]
                    res += dp[index][j]
                dp[i][j] = res % MOD  # python取模默认为正，不用处理
        ans = 0
        for j in range(m):
            ans += dp[n - 1][j]
        return ans % MOD
```

# 2335. 装满杯子需要的最短总时长

> 2023.02.11 贪心

现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 `2` 杯 **不同** 类型的水或者 `1` 杯任意类型的水。

给你一个下标从 **0** 开始、长度为 `3` 的整数数组 `amount` ，其中 `amount[0]`、`amount[1]` 和 `amount[2]` 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 **最少** 秒数。

---

1. 贪心

   ```c++
   class Solution {
   public:
       int fillCups(vector<int>& amount) {
           int res = 0;
           while (true) {
               int maxNum = 0;
               int minNum = INT_MAX;
               for (int& i : amount) {
                   if (i > maxNum) maxNum = i;
                   if (i < minNum && i != 0) minNum = i;
               }
               if (maxNum == 0) break;  // 已经装满了
               for (int& i : amount) {
                   if (i != 0 && i == minNum) {
                       minNum = 0;
                       i--;
                   }
                   if (i != 0 && i == maxNum) {
                       maxNum = 0;
                       i--;
                   }
               }
               res++;  // 消耗一秒
           }
           return res;
       }
   };
   ```

2. 讨论

   水的数量分布有两种情况：

       三种水都比较均衡，每次装其中两个，瓶颈就是总数
       某种水特别多，瓶颈就是数量最多的那种水

   取两者最大值即可

   作者：Whaleee1208
   链接：https://leetcode.cn/problems/minimum-amount-of-time-to-fill-cups/solutions/1667258/c-zui-jian-dan-de-fang-fa-by-whaleee1208-wx79/
   来源：力扣（LeetCode）
   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

   ```python
   class Solution:
       def fillCups(self, amount: List[int]) -> int:
           sumNum = sum(amount)
           maxi = max(amount)
           return max(maxi, sumNum // 2 + sumNum % 2)
   ```

# 1138. 字母板上的路径

> 2023.02.12 模拟 数组

```c++
class Solution {
public:
    string alphabetBoardPath(string target) {
        int tx = 0, ty = 0;
        int x, y;
        string res;
        for (char& c : target) {
            x = (c - 'a') / 5;
            y = (c - 'a') % 5;
            string v(abs(x - tx), "UD"[tx < x]);
            string h(abs(y - ty), "LR"[ty < y]);
            res += c != 'z' ? v + h + "!" : h + v + "!";
            tx = x; ty = y;
        }
        return res;
    }
};
```

```python
class Solution:
    def alphabetBoardPath(self, target: str) -> str:
        res = ""
        nx, ny = 0, 0
        for c in target:
            x = (ord(c) - ord('a')) // 5
            y = (ord(c) - ord('a')) % 5
            v = "UD"[nx < x] * abs(x - nx)
            h = "LR"[ny < y] * abs(y - ny)
            res += (v + h if c != 'z' else h + v) + "!"
            nx, ny = x, y
        return res
```

# 1234. 替换子串得到平衡字符串

> 2022.02.13 字符串 双指针

有一个只含有 `'Q', 'W', 'E', 'R'` 四种字符，且长度为 `n` 的字符串。

假如在该字符串中，这四个字符都恰好出现 `n/4` 次，那么它就是一个「平衡字符串」。

给你一个这样的字符串 `s`，请通过「替换一个子串」的方式，使原字符串 `s` 变成一个「平衡字符串」。

你可以用和「待替换子串」长度相同的 **任何** 其他字符串来完成替换。

请返回待替换子串的最小可能长度。

如果原字符串自身就是一个平衡字符串，则返回 `0`。

---

- 如果在待替换子串**之外**的任意字符的出现次数都不超过 m，那么可以通过替换，使 s 为平衡字符串，即每个字符的出现次数均为 m。
- 设置两个指针，每次更新右指针，在剩余字符数量满足都小于等于m时返回此时子串长度
- 然后移动左指针，记录满足条件的最小子串长度返回

```c++
class Solution {
public:
    int balancedString(string s) {
        unordered_map<char, int> cnt;
        int n = s.size(), m = n / 4;
        for (char& c : s) ++cnt[c];  // 统计每个字符出现的总次数
        if (cnt['Q'] == m && cnt['W'] == m && cnt['E'] == m && cnt['R'] == m) {
            return 0;
        }
        int left = 0, ans = n;
        for (int right = 0; right < n; right++) {
            cnt[s[right]]--;
            while (cnt['Q'] <= m && cnt['W'] <= m && cnt['E'] <= m && cnt['R'] <= m) {
                ans = min(ans, right - left + 1); // 更新最小子串长度
                ++cnt[s[left++]];
            }
        }
        return ans;
    }
};
```

```python
class Solution:
    def balancedString(self, s: str) -> int:
        n = len(s)
        m = n // 4
        cnt = defaultdict(int)
        for c in s:
            cnt[c] += 1
        if cnt['Q'] == m and cnt['W'] == m and cnt['E'] == m and cnt['R'] == m:
            return 0
        left = 0
        ans = n
        for right in range(n):
            cnt[s[right]] -= 1
            while cnt['Q'] <= m and cnt['W'] <= m and cnt['E'] <= m and cnt['R'] <= m:
                ans = min(ans, right- left + 1)
                cnt[s[left]] += 1
                left += 1
        return ans
```

# 1124*. 表现良好的最长时间段

> 2023.02.14 前缀和 单调栈 哈希表

给你一份工作时间表 `hours`，上面记录着某一位员工每天的工作小时数。

我们认为当员工一天中的工作小时数大于 `8` 小时的时候，那么这一天就是「**劳累的一天**」。

所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 **大于**「不劳累的天数」。

请你返回「表现良好时间段」的最大长度。

---

- 大于8的定义为1，小于等于8的定义为-1，就是要求子数组和大于0的最大长度

## 前缀和+单调栈

- 例如 nums=[1,2,−1,2]，对应的前缀和数组为 s=[0,1,3,2,4]。
- 用左闭右开区间 [left,right)来表示子数组，此时子数组的和为 s[right]−s[left]，子数组的长度为 right−left
- 对于子数组和大于0，转换到前缀和中就是s[right] > s[left]

```c++
class Solution {
public:
    int longestWPI(vector<int>& hours) {
        int n = hours.size(), ans = 0;
        vector<int> s(n + 1, 0);
        stack<int> st;  // 单调递减栈
        st.push(0);
        for (int i = 1; i <= hours.size(); i++) {
            s[i] = s[i - 1] + (hours[i - 1] > 8 ? 1 : -1);
            if (s[i] < s[st.top()]) st.push(i);
        }
        for (int i = n; i > 0; i--) {
            while (!st.empty() && s[i] > s[st.top()]) {
                ans = max(ans, i - st.top());
                st.pop();
            }
        }
        return ans;
    }
};
```

```python
class Solution:
    def longestWPI(self, hours: List[int]) -> int:
        ans = 0
        n = len(hours)
        s = [0] * (n + 1)
        st = [0]
        for i in range(1, n + 1):
            s[i] = s[i - 1] + (1 if hours[i - 1] > 8 else -1)
            if s[i] < s[st[-1]]:
                st.append(i)
        for i in range(n, 0, -1):
            while st and s[i] > s[st[-1]]:
                ans = max(ans, i - st.pop())
        return ans
```

## 哈希表（不好想）

利用 nums 中只有 1 和 −1 的特点，可以做到**[一次遍历](https://leetcode.cn/problems/longest-well-performing-interval/solutions/2110211/liang-chong-zuo-fa-liang-zhang-tu-miao-d-hysl/?orderBy=most_votes)**

![image-20230214113755301](E:\书包\MyNotes\算法\每日一题\202302\image-20230214113755301.png)

```c++
class Solution {
public:
    int longestWPI(vector<int>& hours) {
        int n = hours.size(), ans = 0, s = 0;
        vector<int> pos(n + 2, 0);
        for (int i = 1; i <= n; i++) {
            hours[i - 1] > 8 ? s-- :s++;
            if (s < 0) ans = i;
            else {
                if (pos[s + 1]) ans = max(ans, i - pos[s + 1]);
                if (pos[s] == 0) pos[s] = i;
            }
        }
        return ans;
    }
};
```

```python
class Solution:
    def longestWPI(self, hours: List[int]) -> int:
        ans, s = 0, 0
        n = len(hours)
        pos = [0] * (n + 2)
        for i in range(1, n + 1):
            s -= 1 if hours[i - 1] > 8 else -1
            if s < 0: ans = i
            else:
                if pos[s + 1]: ans = max(ans, i - pos[s + 1])
                if pos[s] == 0: pos[s] = i
        return ans
```

# 1250. 检查「好数组」

> 2023.02.15 数学：裴蜀定理

给你一个正整数数组 `nums`，你需要从中任选一些子集，然后将子集中每一个数乘以一个 **任意整数**，并求出他们的和。

假如该和结果为 `1`，那么原数组就是一个「**好数组**」，则返回 `True`；否则请返回 `False`。

---

- 只需要判断在数组 `nums` 中是否存在 i 个互质的数即可
- 进一步转化为判断数组 `nums` 中的所有数的最大公约数是否为 1

```c++
class Solution {
public:
    bool isGoodArray(vector<int>& nums) {
        int factor= 0;  // 最大公因数
        for (int i : nums) {
            factor = gcd(i, factor);
        }
        return factor == 1;
    }
};
```

```python
class Solution:
    def isGoodArray(self, nums: List[int]) -> bool:
        return reduce(gcd, nums) == 1

class Solution:
    def isGoodArray(self, nums: List[int]) -> bool:
        factor = 0
        for i in nums:
            factor = gcd(i, factor)
        return factor == 1
```

# 2341. 数组能形成多少数对

> 2023.02.16 哈希表

给你一个下标从 **0** 开始的整数数组 `nums` 。在一步操作中，你可以执行以下步骤：

- 从 `nums` 选出 **两个** **相等的** 整数
- 从 `nums` 中移除这两个整数，形成一个 **数对**

请你在 `nums` 上多次执行此操作直到无法继续执行。

返回一个下标从 **0** 开始、长度为 `2` 的整数数组 `answer` 作为答案，其中 `answer[0]` 是形成的数对数目，`answer[1]` 是对 `nums` 尽可能执行上述操作后剩下的整数数目。

---

```c++
class Solution {
public:
    vector<int> numberOfPairs(vector<int>& nums) {
        unordered_map<int, bool> dict;
        int res = 0;
        for (int i : nums) {
            if (dict.find(i) != dict.end()) {
                dict[i] = !dict[i];
            } else {
                dict[i] = true;
            }
            if (!dict[i]) res += 1;
        }
        return {res, (int)nums.size() - res * 2};
    }
};
```

```python
class Solution:
    def numberOfPairs(self, nums: List[int]) -> List[int]:
        dic = {}
        res = 0
        for i in nums:
            if i in dic:
                dic[i] = not dic[i]
            else:
                dic[i] = True
            if not dic[i]:
                res += 1
        return [res, len(nums) - 2 * res]
```

# 1139. 最大的以 1 为边界的正方形

> 2023.02.17 动态规划 || 前缀和

给你一个由若干 `0` 和 `1` 组成的二维网格 `grid`，请你找出边界全部由 `1` 组成的最大 **正方形** 子网格，并返回该子网格中的元素数量。如果不存在，则返回 `0`。

---

## 动态规划

- `up[i][j]`为序号i，j上方连续为1的个数
- `left[i][j]`为序号i，j左边连续为1的个数
- 假设当前正方形的边长为 l，此时只需检测 `up[i][j], left[i][j],up[i][j - l + 1],left[i - l + 1][j]` 是否均满足大于等于 l 即可检测正方形的合法性。
- 记录其中最大的满足条件的情况

```c++
class Solution {
public:
    int largest1BorderedSquare(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> left(m + 1, vector<int>(n + 1));
        vector<vector<int>> up(m + 1, vector<int>(n + 1));
        int length, maxLen = 0;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (grid[i - 1][j - 1] == 1) {
                    up[i][j] = up[i - 1][j] + 1;
                    left[i][j] = left[i][j - 1] + 1;
                    length = min(up[i][j], left[i][j]);
                    while (left[i - length + 1][j] < length || up[i][j - length + 1] < length) {
                        length--;
                    }
                    maxLen = max(maxLen, length);
                }
            }
        }
        return maxLen * maxLen;
    }
};
```

## 前缀和

![1139.png](https://pic.leetcode.cn/1676448329-qJcoyK-1139.png)

```python
class Solution:
    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        row = [[0] * (n + 1) for _ in range(m + 1)]
        col = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                row[i][j] = row[i][j - 1] + grid[i - 1][j - 1]
                col[i][j] = col[i - 1][j] + grid[i - 1][j - 1]
        maxLen = 0
        for d in range(min(m, n), 0, -1):
            for i in range(m - d + 1):
                for j in range(n - d + 1):
                    if row[i + 1][j + d] - row[i + 1][j] == d and \
                    row[i + d][j + d] - row[i + d][j] == d and \
                    col[i + d][j + 1] - col[i][j + 1] == d and \
                    col[i + d][j + d] - col[i][j + d] == d:
                        return d * d
        return 0
```

# 1237. 找出给定方程的正整数解

> 2023.02.18 对向双指针

给你一个函数 `f(x, y)` 和一个目标结果 `z`，函数公式未知，请你计算方程 `f(x,y) == z` 所有可能的正整数 **数对** `x` 和 `y`。满足条件的结果数对可以按任意顺序返回。

尽管函数的具体式子未知，但它是单调递增函数，也就是说：

- `f(x, y) < f(x + 1, y)`
- `f(x, y) < f(x, y + 1)`

---

## 双指针

```c++
class Solution {
public:
    vector<vector<int>> findSolution(CustomFunction& customfunction, int z) {
        vector<vector<int>> ans;
        int x = 1, y = 100;
        while (x <= 1000 && y > 0) {
            if (customfunction.f(x, y) < z) x++;
            else if (customfunction.f(x, y) > z) y--;
            else ans.push_back({x++, y--});
        }
        return ans;
    }
};
```

```python
class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        ans = []
        x, y = 1, 1000
        while x <= 1000 and y > 0:
            if customfunction.f(x, y) < z:
                x += 1
            elif customfunction.f(x, y) > z:
                y -= 1
            else:
                ans.append([x, y])
                x += 1
                y -= 1
        return ans
```

## 我的方法

（双百）二分+遍历

```c++
class Solution {
public:
    vector<vector<int>> findSolution(CustomFunction& customfunction, int z) {
        vector<vector<int>> ans;
        int left = 1, right = 1001;
        while (left < right) {
            int mid = (left + right) / 2;
            if (customfunction.f(mid, 1) < z) left++;
            else if (customfunction.f(mid, 1) > z) right--;
            else {
                left = mid;  // 保证left存放大于等于z的最小x值
                ans.push_back({mid, 1});
                break;
            }
        }
        for (int y = 2; y <= 1000; y++) {  // 遍历y
            while (left && customfunction.f(left, y) > z) left--;
            if (left < 1) break;
            if (customfunction.f(left, y) == z) ans.push_back({left, y});
        }
        return ans;
    }
};
```


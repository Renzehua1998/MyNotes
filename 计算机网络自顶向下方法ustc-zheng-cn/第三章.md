# 第三章 传输层

- 传输层的原理。
  1. 多路复用/解复用、
  2. **可靠数据传输（RDT-经典核心内容）**、
  3. 流量控制、
  4. 拥塞控制（原因、表现、检测、控制）。
- 传输层协议。
  1. UDP
  2. TCP
  3. TCP拥塞控制

## 3.1 概述和传输层服务

传输服务和协议：

- **进程之间**以**报文（message）为单位**的**逻辑的**通信。

- 发送方**拆分**为报文段，接收方再去掉头、**重组**。不表示报文界限（字节流的服务）。

- 有多种协议可选：Internet——TCP、UDP。

传输层 vs. 网络层：

- 网络层：主机之间；传输层：**进程之间**。
- 不可靠 -> 可靠是可以加强的；不安全 -> 也是可以加强的；但是延迟和带宽这些品质是不可以加强的。
- 最重要的品质加强：复用/解复用，源端做复用、目标端解复用。（通信的双方互为源和目的）。

Internet传输层协议：

- **可靠的、保序TCP**：多路复用/解复用、拥塞控制、流量控制、建立连接。——字节流
- **不可靠、不保序UDP**：多路复用/解复用、无额外更多的服务。——数据报

二者都不能保证带宽和延迟。

## 3.2 多路复用与解复用

通过端口号来实现多路复用、解复用。TCP socket一个整数包含四元组、UDP socket一个整数包含二元组。

- TCP往下交两个东西：socket、数据内容。源端根据socket提交端口、IP信息，目标端收到后根据端口、IP查询socket向上传递，交给正确的应用进程。
- UDP要多交一个东西：目标端口+IP。源端根据信息传送，目标端根据目标端口+IP信息找到对应socket找到进程。

复用：从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装。

解复用：根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)。

无连接多路复用例子：UDP中socket只与本机IP端口相关，即接收方**只根据目标端口和IP查找socket即可**。

面向连接的解复用例子：**四元组有一个不一样就会定位给不同的socket**，发送到不同的应用进程（同一进程的不同线程）。

## 3.3 无连接传输：UDP

**概述**：仅增加了复用、解复用的功能。没有加入其他新功能。可能有丢失和乱序、无连接。

- 常见应用：流媒体、DNS、SNMP（简单网管协议）。

- 一般常见：流媒体、事务型应用（一次往返解决）。
- UDP上可行可靠传输：应用层增加可靠性、特定差错恢复。

**协议**：UDP数据报格式：

1. 8字节**头部**——2字节源端口号、2字节目的端口号、数据长度（包括头部）、校验和EDC。
2. **报文部分**——校验和出错后全部丢掉。

必要性：不用连接、简单、载荷占比大（头部小）、没有流量拥塞控制。

**校验和**：**校验范围（D）**的和，判断是否出现了差错。没有通过校验一定错，通过校验不一定错（残存错误）。

发送方做差错控制编码，接收方做差错控制解码。——存在保护范围：数据、头部、部分其他内容。按照16bit的单位分开、每16bit全部加起来作为一个校验和。

要注意的部分：除EDC的部分**进位回滚**（进位的1加到末尾），最后结果求反码（**按位取反**）；接收端加出来全1即通过校验。

## 3.4 可靠数据传输的原理

### 问题描述

（一般化的）可靠数据传输（RDT）：可能是数据链路层、应用层等等。下一层是不可靠数据传输（UDT）。

是网络Top 10问题之一。

**rdt_send()**和**deliver_data()**是本层和上层接口的原语；**udt_send()**和**rdt_rcv()**是本层和下层接口的原语。——针对本层来说。

假设：**渐增式**地开发、双向传输的是两个**单向传输**的结合、**有限状态机** (**FSM**) 来描述发送方和接收方。

- 学习方法：先**假设底层完全可靠**，**逐步增加底层的不可靠性**，本层逐步添加机制，直到完成本层全部功能。
- 虽然数据通信是单向的，但是需要双向的信息交换。
- 有限状态机：通过图形的方式表示实体的状态、连接边的分子代表发生的事件、分母代表采取的动作。迁移到哪个状态取决于发生了什么事件。
- 可靠传输的需求：不出错、不丢失。

### 停等协议

（停止等待协议stop and wait）。

#### Rdt1.0

——在可靠信道上的可靠数据传输

下层的信道完全可靠：

- 发送方：接收上层、封装、发送下层。
- 接收方：接收下层、解封装、交给上层。

#### Rdt2

**Rdt2.0——具有比特差错的信道（出错）**

下层信道可能会产生反转出错：

- 确认(**ACK**)、否定确认( **NAK**)：发送方收到NAK后，发送方重传分组。
- 采用差错控制编码进行差错检测（EDC的用处）：差错控制编码、缓存->检错->反馈->相应的动作。

状态有所增加：

- 发送方：接收上层、封装、发送下层->等待对方反馈（NAK始终发旧的，ACK返回初始状态）
- 接收方：接收下层、没出错、解封装、交给上层、发送ACK；接收下层、出错了、发送NAK。

**Rdt2.1——带序号控制**

rdt2.0存在的致命问题：**ACK/NAK可能出错、丢失**。——**序号**（发送方在每个分组中加入序号）

ACK/NAK出错的情况下，重新发送上一个分组，有可能形成**重复**，接收方收到**重复直接丢掉**发送ACK即可。

仅需要**0和1两个序号**，发送方四个状态、接收方两个状态。——一次只发送一个未经确认的分组。

状态都加倍了，因为有了0和1的分别。接收方收到不同于当前状态的分组（没错）时、丢掉再发ACK。

接收方不知道ACK/NAK是否被正确地收到，**根据收到下一个分组的情况**判断有没有收到。

**Rdt2.2——无NAK的协议**（只使用ACK，对它做编号）。

使用**上一个分组的正向确认代替当前分组的反向确认**（为一次发送多个数据单位做好准备）。

确认信息减少一半，协议处理简单。双方出错都能继续回到同步状态。

状态转移图和2.1基本相同，仅使用ACK0代替了NAK1，ACK1代替了NAK0。

#### Rdt3.0

——具有**比特差错**和**分组丢失**的信道（**超时重传**：比正常往返稍微长一点）

动机：分组可能丢失，接收方没有收到，互相等待陷入**死锁**。——需要机制来打破。

超时时间设置不一定相同，数据链路层一般比较确定，传输层根据概率分布动态设置。

延时比较长的情况下重传可能造成数据重复，但是没有关系。

状态转移图也是**四个状态**，不同的是发送分组后**启动定时器**，**超时重传**；收到**不同于当前的ACK继续等待**，直到超时重传（和立即重传效果一样）。

一个数据传输的例子（超时设置的不好：**过早地超时**）：这种情况**效率并不高**，正常情况下50%或更低——一半

的分组和确认是重复的。

Rdt3.0已经是**完备的协议**了，可以对抗复杂的情况（出错、丢失）。

存在的**缺点**：在信道容量比较大的情况下，性能很差。

- 1 Gbps的链路（R），15 ms端-端传播延时（t），RTT=30ms，分组大小为1kB（L）
- 传输延迟8us，利用率0.027%，有效带宽270kbps。
- 瓶颈在协议本身——虽然能实现，但是太慢太慢，利用率非常低。

### 流水线协议

（流水线协议pipeline）。
# 第三章 传输层

- 传输层的原理。
  1. 多路复用/解复用、
  2. **可靠数据传输（RDT-经典核心内容）**、
  3. 流量控制、
  4. 拥塞控制（原因、表现、检测、控制）。
- 传输层协议。
  1. UDP
  2. TCP
  3. TCP拥塞控制

## 3.1 概述和传输层服务

传输服务和协议：

- **进程之间**以**报文（message）为单位**的**逻辑的**通信。

- 发送方**拆分**为报文段，接收方再去掉头、**重组**。不表示报文界限（字节流的服务）。

- 有多种协议可选：Internet——TCP、UDP。

传输层 vs. 网络层：

- 网络层：主机之间；传输层：**进程之间**。
- 不可靠 -> 可靠是可以加强的；不安全 -> 也是可以加强的；但是延迟和带宽这些品质是不可以加强的。
- 最重要的品质加强：复用/解复用，源端做复用、目标端解复用。（通信的双方互为源和目的）。

Internet传输层协议：

- **可靠的、保序TCP**：多路复用/解复用、拥塞控制、流量控制、建立连接。——字节流
- **不可靠、不保序UDP**：多路复用/解复用、无额外更多的服务。——数据报

二者都不能保证带宽和延迟。

```mermaid
graph TB
	A[传输层概述]
	A-->B[协议]
	B-->B1[TCP]
	B-->B2[UDP]
	A-->D[进程间通信]
	A-->C[与网络层对比]
	C-->C1[主机与进程]
	C-->C2[复用/解复用]
```

## 3.2 多路复用与解复用

通过端口号来实现多路复用、解复用。TCP socket一个整数包含四元组、UDP socket一个整数包含二元组。

- TCP往下交两个东西：socket、数据内容。源端根据socket提交端口、IP信息，目标端收到后根据端口、IP查询socket向上传递，交给正确的应用进程。
- UDP要多交一个东西：目标端口+IP。源端根据信息传送，目标端根据目标端口+IP信息找到对应socket找到进程。

复用：从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装。

解复用：根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)。

无连接多路复用例子：UDP中socket只与本机IP端口相关，即接收方**只根据目标端口和IP查找socket即可**。

面向连接的解复用例子：**四元组有一个不一样就会定位给不同的socket**，发送到不同的应用进程（同一进程的不同线程）。

```mermaid
graph TB
	A[多路复用/解复用]
	A-->B[TCP/四元组]
	B-->B1[复用]
	B-->B2[解复用]
	A-->C[UDP/二元组]
	C-->C1[复用]
	C-->C2[解复用]
```

## 3.3 无连接传输：UDP

**概述**：仅增加了复用、解复用的功能。没有加入其他新功能。可能有丢失和乱序、无连接。

- 常见应用：流媒体、DNS、SNMP（简单网管协议）。

- 一般常见：流媒体、事务型应用（一次往返解决）。
- UDP上可行可靠传输：应用层增加可靠性、特定差错恢复。

**协议**：UDP数据报格式：

1. 8字节**头部**——2字节源端口号、2字节目的端口号、数据长度（包括头部）、校验和EDC。
2. **报文部分**——校验和出错后全部丢掉。

必要性：不用连接、简单、载荷占比大（头部小）、没有流量拥塞控制。

**校验和**：**校验范围（D）**的和，判断是否出现了差错。没有通过校验一定错，通过校验不一定错（残存错误）。

发送方做差错控制编码，接收方做差错控制解码。——存在保护范围：数据、头部、部分其他内容。按照16bit的单位分开、每16bit全部加起来作为一个校验和。

要注意的部分：除EDC的部分**进位回滚**（进位的1加到末尾），最后结果求反码（**按位取反**）；接收端加出来全1即通过校验。

```mermaid
graph TB
	A[无连接传输: UDP]
	A-->B[概述]
	B-->B1[功能:复用/解复用]
	B-->B2[常见应用]
	A-->C[协议]
	C-->C1[校验和-进位回滚]
	C-->C2[残存错误]
```

## 3.4 可靠数据传输的原理

### 问题描述

（一般化的）可靠数据传输（RDT）：可能是数据链路层、应用层等等。下一层是不可靠数据传输（UDT）。

是网络Top 10问题之一。

**rdt_send()**和**deliver_data()**是本层和上层接口的原语；**udt_send()**和**rdt_rcv()**是本层和下层接口的原语。——针对本层来说。

假设：**渐增式**地开发、双向传输的是两个**单向传输**的结合、**有限状态机** (**FSM**) 来描述发送方和接收方。

- 学习方法：先**假设底层完全可靠**，**逐步增加底层的不可靠性**，本层逐步添加机制，直到完成本层全部功能。
- 虽然数据通信是单向的，但是需要双向的信息交换。
- 有限状态机：通过图形的方式表示实体的状态、连接边的分子代表发生的事件、分母代表采取的动作。迁移到哪个状态取决于发生了什么事件。
- 可靠传输的需求：不出错、不丢失。

### 停等协议

（停止等待协议stop and wait）。

#### Rdt1.0

——在可靠信道上的可靠数据传输

下层的信道完全可靠：

- 发送方：接收上层、封装、发送下层。
- 接收方：接收下层、解封装、交给上层。

#### Rdt2

**Rdt2.0——具有比特差错的信道（出错）**

下层信道可能会产生反转出错：

- 确认(**ACK**)、否定确认( **NAK**)：发送方收到NAK后，发送方重传分组。
- 采用差错控制编码进行差错检测（EDC的用处）：差错控制编码、缓存->检错->反馈->相应的动作。

状态有所增加：

- 发送方：接收上层、封装、发送下层->等待对方反馈（NAK始终发旧的，ACK返回初始状态）
- 接收方：接收下层、没出错、解封装、交给上层、发送ACK；接收下层、出错了、发送NAK。

**Rdt2.1——带序号控制**

rdt2.0存在的致命问题：**ACK/NAK可能出错、丢失**。——**序号**（发送方在每个分组中加入序号）

ACK/NAK出错的情况下，重新发送上一个分组，有可能形成**重复**，接收方收到**重复直接丢掉**发送ACK即可。

仅需要**0和1两个序号**，发送方四个状态、接收方两个状态。——一次只发送一个未经确认的分组。

状态都加倍了，因为有了0和1的分别。接收方收到不同于当前状态的分组（没错）时、丢掉再发ACK。

接收方不知道ACK/NAK是否被正确地收到，**根据收到下一个分组的情况**判断有没有收到。

**Rdt2.2——无NAK的协议**（只使用ACK，对它做编号）。

使用**上一个分组的正向确认代替当前分组的反向确认**（为一次发送多个数据单位做好准备）。

确认信息减少一半，协议处理简单。双方出错都能继续回到同步状态。

状态转移图和2.1基本相同，仅使用ACK0代替了NAK1，ACK1代替了NAK0。

#### Rdt3.0

——具有**比特差错**和**分组丢失**的信道（**超时重传**：比正常往返稍微长一点）

动机：分组可能丢失，接收方没有收到，互相等待陷入**死锁**。——需要机制来打破。

超时时间设置不一定相同，数据链路层一般比较确定，传输层根据概率分布动态设置。

延时比较长的情况下重传可能造成数据重复，但是没有关系。

状态转移图也是**四个状态**，不同的是发送分组后**启动定时器**，**超时重传**；收到**不同于当前的ACK继续等待**，直到超时重传（和立即重传效果一样）。

一个数据传输的例子（超时设置的不好：**过早地超时**）：这种情况**效率并不高**，正常情况下50%或更低——一半

的分组和确认是重复的。

Rdt3.0已经是**完备的协议**了，可以对抗复杂的情况（出错、丢失）。

存在的**缺点**：在信道容量比较大的情况下，性能很差。

- 1 Gbps的链路（R），15 ms端-端传播延时（t），RTT=30ms，分组大小为1kB（L）
- 传输延迟8us，利用率0.027%，有效带宽270kbps。
- 瓶颈在协议本身——虽然能实现，但是太慢太慢，利用率非常低。

### 流水线协议

（流水线协议pipeline）。

允许发送方在未得到对方确认的情况下一次发送多个分组，最大限度地利用线路资源。增加序号的范围，有缓冲区进行控制。

最经典的**流水线协议**（管道化协议）。两种分类——**回退N步**(GBN go back N)、**选择重传**(SR selective repeat)。

缓冲区目的：发送方（选择重传）、接收方（速度匹配）。

#### 滑动窗口协议

先看一般性协议**滑动窗口**协议（SW slide window）。

对于滑动窗口：SW=1，RW=1，停等；SW>1，RW=1，退回N步；SW>1，RW>1，选择重传。

**发送缓冲区**：发送方同时能够发送多少未经确认的分组（没有确认需要缓存）。链路利用率不能够超100%

**发送窗口**：发送缓冲区的**子集**，存放已发送未确认的分组。**发送窗口最大值小于等于发送缓冲区大小**。

相对表示：分组不动、窗口向前滑动。

前沿滑动：发送出去一个分组，前沿往向前滑动；后沿滑动：收到确认后沿向前滑动（不能超过前沿）。

**接收窗口**：（等同于接收缓冲区）——接收方愿意接收多少分组。

- RW=1，始终给出正确到来分组顺序到来最高序号的确认。**回退N步**——累积确认
- RW>1，收到接收窗口低序号最边缘的分组，才可以向前滑动。高序号到来可以缓存**选择重传**——非累积确认

**窗口互动**：

1. 正常情况：同步向前滑动、传输过程不失序。发送方发送，前沿前滑；接收窗口接收、前滑、确认；发送后沿前滑。
2. 异常GBN互动方式：最后分组乱序（丢失）到达。后面到来的分组抛弃掉，发送累积确认，发送方超时重新发送全部分组。
3. 异常SR互动方式：分组乱序（丢失）到达，前面分组的确认始终没来，触发超时机制，只发送前方未经确认的分组，后面收到的不再重发。（每个分组提供一个定时器）。

GBN、SR相同点：一次能够可发送多个未经确认的分组；区别：乱序或丢失是否需要全部重发、累计确认vs非累计确认、是否为每个分组添加一个定时器。

#### GBN协议

发送方有限状态机：

- 初始化窗口=0 next=base。
- 新来分组在缓冲区范围之内，可以发送，base=next时，重设定时器。
- 超时了，窗口内全部重发。
- 收到确认信号，后沿向前滑动，base=next时，重设定时器。。

接收方有限状态机：

- 初始化进入到等待状态，用一个变量维护等待接收位置。
- 来到分组通过校验，序号和当前等待序号相同，解封装上交，发送确认，接收窗口向前滑动。
- 乱序分组之间丢弃，仅提供最高顺序分组的确认。

#### SR协议

非累积确认，仅对未确认分组进行重传。

**主要区别**：

- 发送方：每个分组设置定时器，重传超时的对应分组、收到最低确认，直接移到最低未确认处。
- 接收方：乱序数据缓存，低分组到来后同一上交，忽略超过范围的分组。

GBN简单，但是需要回退N步，出错回退代价大。SR复杂要维护多个缓冲区和定时器，回退代价小。

分组编号比特数为n时（序号空间大小），GBN协议最大窗口大小为2\^n-1，SR协议最大窗口大小为2\^(n-1)

```mermaid
graph TB
	A[可靠数据传输的原理]
	A-->B[停等协议]
	B-->B1[rdt1.0]
	B-->B2[rdt2.0-2.2]
	B2-->B21[确认信号]
	B2-->B22[序号控制]
	B2-->B23[信号复用]
	B-->B3[rdt3.0]
	B3-->B31[重传]
	A-->C[流水线协议]
	C-->C0[滑动窗口]
	C0-->C1[GBN协议]
	C0-->C2[SR协议]
```

## 3.5 面向连接的传输：TCP